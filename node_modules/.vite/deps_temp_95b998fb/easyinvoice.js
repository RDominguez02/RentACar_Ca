import {
  require_fs,
  require_url
} from "./chunk-IB75MFVW.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __require,
  __toESM
} from "./chunk-CLC6CPQL.js";

// node_modules/easyinvoice/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function encode2(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode2(key) + "=" + encode2(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/AxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module2.exports = AxiosError;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/defaults/transitional.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/toFormData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build2(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build2(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build2(obj);
      return formData;
    }
    module2.exports = toFormData;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/cancel/CanceledError.js"(exports2, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils = require_utils();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module2.exports = CanceledError;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/parseProtocol.js"(exports2, module2) {
    "use strict";
    module2.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/null.js
var require_null = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/null.js"(exports2, module2) {
    module2.exports = null;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/defaults/index.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION2 = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version3, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version3 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version3 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module2.exports = Axios;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/easyinvoice/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/easyinvoice/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/easyinvoice/node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/is-base64/is-base64.js
var require_is_base64 = __commonJS({
  "node_modules/is-base64/is-base64.js"(exports2, module2) {
    (function(root) {
      "use strict";
      function isBase642(v, opts) {
        if (v instanceof Boolean || typeof v === "boolean") {
          return false;
        }
        if (!(opts instanceof Object)) {
          opts = {};
        }
        if (opts.allowEmpty === false && v === "") {
          return false;
        }
        var regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?";
        var mimeRegex = "(data:\\w+\\/[a-zA-Z\\+\\-\\.]+;base64,)";
        if (opts.mimeRequired === true) {
          regex = mimeRegex + regex;
        } else if (opts.allowMime === true) {
          regex = mimeRegex + "?" + regex;
        }
        if (opts.paddingRequired === false) {
          regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?";
        }
        return new RegExp("^" + regex + "$", "gi").test(v);
      }
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = isBase642;
        }
        exports2.isBase64 = isBase642;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return isBase642;
        });
      } else {
        root.isBase64 = isBase642;
      }
    })(exports2);
  }
});

// node_modules/file-saver/dist/FileSaver.min.js
var require_FileSaver_min = __commonJS({
  "node_modules/file-saver/dist/FileSaver.min.js"(exports2, module2) {
    (function(a, b) {
      if ("function" == typeof define && define.amd)
        define([], b);
      else if ("undefined" != typeof exports2)
        b();
      else {
        b(), a.FileSaver = { exports: {} }.exports;
      }
    })(exports2, function() {
      "use strict";
      function b(a2, b2) {
        return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
      }
      function c(a2, b2, c2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
          g(d2.response, b2, c2);
        }, d2.onerror = function() {
          console.error("could not download file");
        }, d2.send();
      }
      function d(a2) {
        var b2 = new XMLHttpRequest();
        b2.open("HEAD", a2, false);
        try {
          b2.send();
        } catch (a3) {
        }
        return 200 <= b2.status && 299 >= b2.status;
      }
      function e(a2) {
        try {
          a2.dispatchEvent(new MouseEvent("click"));
        } catch (c2) {
          var b2 = document.createEvent("MouseEvents");
          b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
        }
      }
      var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
          i.revokeObjectURL(j.href);
        }, 4e4), setTimeout(function() {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
        if (g2 = g2 || f2.name || "download", "string" != typeof f2)
          navigator.msSaveOrOpenBlob(b(f2, h), g2);
        else if (d(f2))
          c(f2, g2, h);
        else {
          var i = document.createElement("a");
          i.href = f2, i.target = "_blank", setTimeout(function() {
            e(i);
          });
        }
      } : function(b2, d2, e2, g2) {
        if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
          return c(b2, d2, e2);
        var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
          var k = new FileReader();
          k.onloadend = function() {
            var a2 = k.result;
            a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
          }, k.readAsDataURL(b2);
        } else {
          var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
          g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
            l.revokeObjectURL(m);
          }, 4e4);
        }
      });
      f.saveAs = g.saveAs = g, "undefined" != typeof module2 && (module2.exports = g);
    });
  }
});

// browser-external:canvas
var require_canvas = __commonJS({
  "browser-external:canvas"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "canvas" has been externalized for browser compatibility. Cannot access "canvas.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2) => {
              var _settled;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.RenderingIntentFlag = exports2.PromiseCapability = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.MAX_IMAGE_SIZE_TO_CACHE = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.BASELINE_FACTOR = exports2.AnnotationType = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual;
              exports2.normalizeUnicode = normalizeUnicode;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              ;
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const MAX_IMAGE_SIZE_TO_CACHE = 1e7;
              exports2.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
              exports2.BASELINE_FACTOR = BASELINE_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                SAVE: 8,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                STAMP: 13,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url) {
                switch (url == null ? void 0 : url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      const dots = url.match(/\./g);
                      if ((dots == null ? void 0 : dots.length) >= 2) {
                        url = `http://${url}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String(url);
                      } catch {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch {
                }
                return null;
              }
              function shadow(obj, prop, value, nonSerializable = false) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: !nonSerializable,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str) {
                if (typeof str !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length = str.length;
                const bytes = new Uint8Array(length);
                for (let i = 0; i < length; ++i) {
                  bytes[i] = str.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj[key] = value;
                }
                return obj;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
                static get platform() {
                  if (typeof navigator === "undefined") {
                    return shadow(this, "platform", {
                      isWin: false,
                      isMac: false
                    });
                  }
                  return shadow(this, "platform", {
                    isWin: navigator.platform.includes("Win"),
                    isMac: navigator.platform.includes("Mac")
                  });
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = this.applyTransform(r, m);
                  const p2 = this.applyTransform(r.slice(2, 4), m);
                  const p3 = this.applyTransform([r[0], r[3]], m);
                  const p4 = this.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t = -c / b;
                      if (0 < t && t < 1) {
                        tvalues.push(t);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t2 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                      tvalues.push(t2);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t = tvalues[j];
                    mt = 1 - t;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str) {
                if (str[0] >= "ï") {
                  let encoding;
                  if (str[0] === "þ" && str[1] === "ÿ") {
                    encoding = "utf-16be";
                  } else if (str[0] === "ÿ" && str[1] === "þ") {
                    encoding = "utf-16le";
                  } else if (str[0] === "ï" && str[1] === "»" && str[2] === "¿") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
                return strBuf.join("");
              }
              function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
              }
              function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
              }
              function isArrayBuffer(v) {
                return typeof v === "object" && (v == null ? void 0 : v.byteLength) !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              class PromiseCapability {
                constructor() {
                  __privateAdd(this, _settled, false);
                  this.promise = new Promise((resolve, reject) => {
                    this.resolve = (data) => {
                      __privateSet(this, _settled, true);
                      resolve(data);
                    };
                    this.reject = (reason) => {
                      __privateSet(this, _settled, true);
                      reject(reason);
                    };
                  });
                }
                get settled() {
                  return __privateGet(this, _settled);
                }
              }
              _settled = new WeakMap();
              exports2.PromiseCapability = PromiseCapability;
              let NormalizeRegex = null;
              let NormalizationMap = null;
              function normalizeUnicode(str) {
                if (!NormalizeRegex) {
                  NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                  NormalizationMap = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
                }
                return str.replaceAll(NormalizeRegex, (_, p1, p2) => {
                  return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
                });
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              var _docId, _delayedCleanupTimeout, _pendingCleanup, _tryCleanup, tryCleanup_fn, _abortDelayedCleanup, abortDelayedCleanup_fn, _listeners, _deferred, _a, _workerPorts, _methodPromises, _pageCache, _pagePromises, _cacheSimpleMethod, cacheSimpleMethod_fn, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(3);
              var _display_utils = __w_pdfjs_require__(6);
              var _font_loader = __w_pdfjs_require__(9);
              var _canvas = __w_pdfjs_require__(11);
              var _worker_options = __w_pdfjs_require__(14);
              var _is_node = __w_pdfjs_require__(10);
              var _message_handler = __w_pdfjs_require__(15);
              var _metadata = __w_pdfjs_require__(16);
              var _optional_content_config = __w_pdfjs_require__(17);
              var _transport_stream = __w_pdfjs_require__(18);
              var _xfa_text = __w_pdfjs_require__(19);
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              const DELAYED_CLEANUP_TIMEOUT = 5e3;
              const DefaultCanvasFactory = _is_node.isNodeJS ? __w_pdfjs_require__(20).NodeCanvasFactory : _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              const DefaultCMapReaderFactory = _is_node.isNodeJS ? __w_pdfjs_require__(20).NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              const DefaultFilterFactory = _is_node.isNodeJS ? __w_pdfjs_require__(20).NodeFilterFactory : _display_utils.DOMFilterFactory;
              exports.DefaultFilterFactory = DefaultFilterFactory;
              const DefaultStandardFontDataFactory = _is_node.isNodeJS ? __w_pdfjs_require__(20).NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              let createPDFNetworkStream;
              {
                if (_is_node.isNodeJS) {
                  const {
                    PDFNodeStream
                  } = __w_pdfjs_require__(21);
                  createPDFNetworkStream = (params) => {
                    return new PDFNodeStream(params);
                  };
                } else {
                  const {
                    PDFNetworkStream
                  } = __w_pdfjs_require__(24);
                  const {
                    PDFFetchStream
                  } = __w_pdfjs_require__(25);
                  createPDFNetworkStream = (params) => {
                    return (0, _display_utils.isValidFetchUrl)(params.url) ? new PDFFetchStream(params) : new PDFNetworkStream(params);
                  };
                }
              }
              function getDocument(src) {
                if (typeof src === "string" || src instanceof URL) {
                  src = {
                    url: src
                  };
                } else if ((0, _util.isArrayBuffer)(src)) {
                  src = {
                    data: src
                  };
                }
                if (typeof src !== "object") {
                  throw new Error("Invalid parameter in getDocument, need parameter object.");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                const task = new PDFDocumentLoadingTask();
                const {
                  docId
                } = task;
                const url = src.url ? getUrlProp(src.url) : null;
                const data = src.data ? getDataProp(src.data) : null;
                const httpHeaders = src.httpHeaders || null;
                const withCredentials = src.withCredentials === true;
                const password = src.password ?? null;
                const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
                const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
                let worker2 = src.worker instanceof PDFWorker ? src.worker : null;
                const verbosity = src.verbosity;
                const docBaseUrl = typeof src.docBaseUrl === "string" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;
                const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
                const cMapPacked = src.cMapPacked !== false;
                const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
                const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
                const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
                const ignoreErrors = src.stopAtErrors !== true;
                const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
                const isEvalSupported = src.isEvalSupported !== false;
                const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !_is_node.isNodeJS;
                const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
                const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : _is_node.isNodeJS;
                const fontExtraProperties = src.fontExtraProperties === true;
                const enableXfa = src.enableXfa === true;
                const ownerDocument = src.ownerDocument || globalThis.document;
                const disableRange = src.disableRange === true;
                const disableStream = src.disableStream === true;
                const disableAutoFetch = src.disableAutoFetch === true;
                const pdfBug = src.pdfBug === true;
                const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
                const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !_is_node.isNodeJS && !disableFontFace;
                const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);
                const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
                  ownerDocument
                });
                const filterFactory = src.filterFactory || new DefaultFilterFactory({
                  docId,
                  ownerDocument
                });
                const styleElement = null;
                (0, _util.setVerbosityLevel)(verbosity);
                const transportFactory = {
                  canvasFactory,
                  filterFactory
                };
                if (!useWorkerFetch) {
                  transportFactory.cMapReaderFactory = new CMapReaderFactory({
                    baseUrl: cMapUrl,
                    isCompressed: cMapPacked
                  });
                  transportFactory.standardFontDataFactory = new StandardFontDataFactory({
                    baseUrl: standardFontDataUrl
                  });
                }
                if (!worker2) {
                  const workerParams = {
                    verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const fetchDocParams = {
                  docId,
                  apiVersion: "3.8.162",
                  data,
                  password,
                  disableAutoFetch,
                  rangeChunkSize,
                  length,
                  docBaseUrl,
                  enableXfa,
                  evaluatorOptions: {
                    maxImageSize,
                    disableFontFace,
                    ignoreErrors,
                    isEvalSupported,
                    isOffscreenCanvasSupported,
                    canvasMaxAreaInBytes,
                    fontExtraProperties,
                    useSystemFonts,
                    cMapUrl: useWorkerFetch ? cMapUrl : null,
                    standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
                  }
                };
                const transportParams = {
                  ignoreErrors,
                  isEvalSupported,
                  disableFontFace,
                  fontExtraProperties,
                  enableXfa,
                  ownerDocument,
                  disableAutoFetch,
                  pdfBug,
                  styleElement
                };
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, fetchDocParams);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length,
                        initialData: rangeTransport.initialData,
                        progressiveDone: rangeTransport.progressiveDone,
                        contentDispositionFilename: rangeTransport.contentDispositionFilename,
                        disableRange,
                        disableStream
                      }, rangeTransport);
                    } else if (!data) {
                      networkStream = createPDFNetworkStream({
                        url,
                        length,
                        httpHeaders,
                        withCredentials,
                        rangeChunkSize,
                        disableRange,
                        disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", source, source.data ? [source.data.buffer] : null);
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              function getUrlProp(val) {
                if (val instanceof URL) {
                  return val.href;
                }
                try {
                  return new URL(val, window.location).href;
                } catch {
                  if (_is_node.isNodeJS && typeof val === "string") {
                    return val;
                  }
                }
                throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
              }
              function getDataProp(val) {
                if (_is_node.isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
                  throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
                }
                if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
                  return val;
                }
                if (typeof val === "string") {
                  return (0, _util.stringToBytes)(val);
                }
                if (typeof val === "object" && !isNaN(val == null ? void 0 : val.length) || (0, _util.isArrayBuffer)(val)) {
                  return new Uint8Array(val);
                }
                throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
              }
              const _PDFDocumentLoadingTask = class {
                constructor() {
                  this._capability = new _util.PromiseCapability();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  var _a2;
                  this.destroyed = true;
                  await ((_a2 = this._transport) == null ? void 0 : _a2.destroy());
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              };
              let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
              _docId = new WeakMap();
              __privateAdd(PDFDocumentLoadingTask, _docId, 0);
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              class PDFDataRangeTransport {
                constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
                  this.length = length;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = new _util.PromiseCapability();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get filterFactory() {
                  return this._transport.filterFactory;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get isPureXfa() {
                  return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id) {
                  return this._transport.getDestination(id);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJavaScript() {
                  return this._transport.getJavaScript();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                saveDocument() {
                  return this._transport.saveDocument();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup(keepLoadedFonts = false) {
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, pdfBug = false) {
                  __privateAdd(this, _tryCleanup);
                  __privateAdd(this, _abortDelayedCleanup);
                  __privateAdd(this, _delayedCleanupTimeout, null);
                  __privateAdd(this, _pendingCleanup, false);
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._maybeCleanupAfterRender = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport({
                  scale,
                  rotation = this.rotate,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                } = {}) {
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations({
                  intent = "display"
                } = {}) {
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                }
                getJSActions() {
                  return this._transport.getPageJSActions(this._pageIndex);
                }
                get filterFactory() {
                  return this._transport.filterFactory;
                }
                get isPureXfa() {
                  return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                }
                async getXfa() {
                  var _a2;
                  return ((_a2 = this._transport._htmlForXfa) == null ? void 0 : _a2.children[this._pageIndex]) || null;
                }
                render({
                  canvasContext,
                  viewport,
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  transform = null,
                  background = null,
                  optionalContentConfigPromise = null,
                  annotationCanvasMap = null,
                  pageColors = null,
                  printAnnotationStorage = null
                }) {
                  var _a2, _b;
                  (_a2 = this._stats) == null ? void 0 : _a2.time("Overall");
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  __privateSet(this, _pendingCleanup, false);
                  __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = new _util.PromiseCapability();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    (_b = this._stats) == null ? void 0 : _b.time("Page Request");
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    var _a3, _b2;
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this._maybeCleanupAfterRender || intentPrint) {
                      __privateSet(this, _pendingCleanup, true);
                    }
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, !intentPrint);
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    (_a3 = this._stats) == null ? void 0 : _a3.timeEnd("Rendering");
                    (_b2 = this._stats) == null ? void 0 : _b2.timeEnd("Overall");
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: this._transport.canvasFactory,
                    filterFactory: this._transport.filterFactory,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                    var _a3;
                    if (this.destroyed) {
                      complete();
                      return;
                    }
                    (_a3 = this._stats) == null ? void 0 : _a3.time("Rendering");
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList({
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  printAnnotationStorage = null
                } = {}) {
                  var _a2;
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = new _util.PromiseCapability();
                    (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    (_a2 = this._stats) == null ? void 0 : _a2.time("Page Request");
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent({
                  includeMarkedContent = false,
                  disableNormalization = false
                } = {}) {
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    includeMarkedContent: includeMarkedContent === true,
                    disableNormalization: disableNormalization === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent(params = {}) {
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value.styles);
                        textContent.items.push(...value.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._transport.getStructTree(this._pageIndex);
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  __privateSet(this, _pendingCleanup, false);
                  __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                  return Promise.all(waitOn);
                }
                cleanup(resetStats = false) {
                  __privateSet(this, _pendingCleanup, true);
                  const success = __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                  if (resetStats && success) {
                    this._stats && (this._stats = new _display_utils.StatTimer());
                  }
                  return success;
                }
                _startRenderPage(transparency, cacheKey) {
                  var _a2, _b;
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  (_a2 = this._stats) == null ? void 0 : _a2.timeEnd("Page Request");
                  (_b = intentState.displayReadyCapability) == null ? void 0 : _b.resolve(transparency);
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                  }
                }
                _pumpOperatorList({
                  renderingIntent,
                  cacheKey,
                  annotationStorageSerializable
                }) {
                  const {
                    map,
                    transfers
                  } = annotationStorageSerializable;
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: map
                  }, transfers);
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then(({
                      value,
                      done
                    }) => {
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList({
                  intentState,
                  reason,
                  force = false
                }) {
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      let delay = RENDERING_CANCELLED_TIMEOUT;
                      if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
                        delay += reason.extraDelay;
                      }
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        intentState.streamReaderCancelTimeout = null;
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                      }, delay);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              _delayedCleanupTimeout = new WeakMap();
              _pendingCleanup = new WeakMap();
              _tryCleanup = new WeakSet();
              tryCleanup_fn = function(delayed = false) {
                __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                if (!__privateGet(this, _pendingCleanup) || this.destroyed) {
                  return false;
                }
                if (delayed) {
                  __privateSet(this, _delayedCleanupTimeout, setTimeout(() => {
                    __privateSet(this, _delayedCleanupTimeout, null);
                    __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                  }, DELAYED_CLEANUP_TIMEOUT));
                  return false;
                }
                for (const {
                  renderTasks,
                  operatorList
                } of this._intentStates.values()) {
                  if (renderTasks.size > 0 || !operatorList.lastChunk) {
                    return false;
                  }
                }
                this._intentStates.clear();
                this.objs.clear();
                __privateSet(this, _pendingCleanup, false);
                return true;
              };
              _abortDelayedCleanup = new WeakSet();
              abortDelayedCleanup_fn = function() {
                if (__privateGet(this, _delayedCleanupTimeout)) {
                  clearTimeout(__privateGet(this, _delayedCleanupTimeout));
                  __privateSet(this, _delayedCleanupTimeout, null);
                }
              };
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
                  __privateAdd(this, _deferred, Promise.resolve());
                }
                postMessage(obj, transfer) {
                  const event = {
                    data: structuredClone(obj, transfer ? {
                      transfer
                    } : null)
                  };
                  __privateGet(this, _deferred).then(() => {
                    for (const listener of __privateGet(this, _listeners)) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name, listener) {
                  __privateGet(this, _listeners).add(listener);
                }
                removeEventListener(name, listener) {
                  __privateGet(this, _listeners).delete(listener);
                }
                terminate() {
                  __privateGet(this, _listeners).clear();
                }
              }
              _listeners = new WeakMap();
              _deferred = new WeakMap();
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  const pdfjsFilePath = (_a = document == null ? void 0 : document.currentScript) == null ? void 0 : _a.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url) {
                  const wrapper = `importScripts("${url}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              const _PDFWorker = class {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && __privateGet(_PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = new _util.PromiseCapability();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    __privateGet(_PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                  this._messageHandler.send("configure", {
                    verbosity: this.verbosity
                  });
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = _PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  __privateGet(_PDFWorker, _workerPorts).delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!(params == null ? void 0 : params.port)) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (__privateGet(this, _workerPorts).has(params.port)) {
                    return __privateGet(this, _workerPorts).get(params.port);
                  }
                  return new _PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_is_node.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  var _a2;
                  try {
                    return ((_a2 = globalThis.pdfjsWorker) == null ? void 0 : _a2.WorkerMessageHandler) || null;
                  } catch {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              };
              let PDFWorker = _PDFWorker;
              _workerPorts = new WeakMap();
              __privateAdd(PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
              exports.PDFWorker = PDFWorker;
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params, factory) {
                  __privateAdd(this, _cacheSimpleMethod);
                  __privateAdd(this, _methodPromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  this.canvasFactory = factory.canvasFactory;
                  this.filterFactory = factory.filterFactory;
                  this.cMapReaderFactory = factory.cMapReaderFactory;
                  this.standardFontDataFactory = factory.standardFontDataFactory;
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = new _util.PromiseCapability();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationStorageSerializable = _annotation_storage.SerializableEmpty;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationStorageSerializable = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
                    annotationStorageSerializable
                  };
                }
                destroy() {
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = new _util.PromiseCapability();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  const waitOn = [];
                  for (const page of __privateGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  __privateGet(this, _pageCache).clear();
                  __privateGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    __privateGet(this, _methodPromises).clear();
                    this.filterFactory.destroy();
                    if (this._networkStream) {
                      this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = new _util.PromiseCapability();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      var _a2;
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          var _a3;
                          (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, {
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", ({
                    pdfInfo
                  }) => {
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    this._passwordCapability = new _util.PromiseCapability();
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          this._passwordCapability.reject(password);
                        } else {
                          this._passwordCapability.resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    var _a2;
                    (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = __privateGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", ([id, type, exportedData]) => {
                    var _a2;
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        const inspectFont = params.pdfBug && ((_a2 = globalThis.FontInspector) == null ? void 0 : _a2.enabled) ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
                        const font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          inspectFont
                        });
                        this.fontLoader.bind(font).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font.data) {
                            font.data = null;
                          }
                          this.commonObjs.resolve(id, font);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                      case "Pattern":
                        this.commonObjs.resolve(id, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type}`);
                    }
                  });
                  messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
                    var _a2;
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Image":
                        pageProxy.objs.resolve(id, imageData);
                        if (imageData) {
                          let length;
                          if (imageData.bitmap) {
                            const {
                              width,
                              height
                            } = imageData;
                            length = width * height * 4;
                          } else {
                            length = ((_a2 = imageData.data) == null ? void 0 : _a2.length) || 0;
                          }
                          if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {
                            pageProxy._maybeCleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    var _a2;
                    if (this.destroyed) {
                      return;
                    }
                    (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.cMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.cMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.standardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.standardFontDataFactory.fetch(data);
                  });
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                saveDocument() {
                  var _a2;
                  if (this.annotationStorage.size <= 0) {
                    (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  const {
                    map,
                    transfers
                  } = this.annotationStorage.serializable;
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: map,
                    filename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null
                  }, transfers).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
                    __privateGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  __privateGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                getFieldObjects() {
                  return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetFieldObjects");
                }
                hasJSActions() {
                  return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "HasJSActions");
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id) {
                  if (typeof id !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
                getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  const name = "GetMetadata", cachedPromise = __privateGet(this, _methodPromises).get(name);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise(name, null).then((results) => {
                    var _a2, _b;
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null,
                      contentLength: ((_b = this._fullReader) == null ? void 0 : _b.contentLength) ?? null
                    };
                  });
                  __privateGet(this, _methodPromises).set(name, promise);
                  return promise;
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup(keepLoadedFonts = false) {
                  if (this.destroyed) {
                    return;
                  }
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  for (const page of __privateGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  __privateGet(this, _methodPromises).clear();
                  this.filterFactory.destroy(true);
                }
                get loadingParams() {
                  const {
                    disableAutoFetch,
                    enableXfa
                  } = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch,
                    enableXfa
                  });
                }
              }
              _methodPromises = new WeakMap();
              _pageCache = new WeakMap();
              _pagePromises = new WeakMap();
              _cacheSimpleMethod = new WeakSet();
              cacheSimpleMethod_fn = function(name, data = null) {
                const cachedPromise = __privateGet(this, _methodPromises).get(name);
                if (cachedPromise) {
                  return cachedPromise;
                }
                const promise = this.messageHandler.sendWithPromise(name, data);
                __privateGet(this, _methodPromises).set(name, promise);
                return promise;
              };
              class PDFObjects {
                constructor() {
                  __privateAdd(this, _ensureObj);
                  __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                }
                get(objId, callback = null) {
                  if (callback) {
                    const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj2.capability.promise.then(() => callback(obj2.data));
                    return null;
                  }
                  const obj = __privateGet(this, _objs)[objId];
                  if (!(obj == null ? void 0 : obj.capability.settled)) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj.data;
                }
                has(objId) {
                  const obj = __privateGet(this, _objs)[objId];
                  return (obj == null ? void 0 : obj.capability.settled) || false;
                }
                resolve(objId, data = null) {
                  const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj.data = data;
                  obj.capability.resolve();
                }
                clear() {
                  var _a2;
                  for (const objId in __privateGet(this, _objs)) {
                    const {
                      data
                    } = __privateGet(this, _objs)[objId];
                    (_a2 = data == null ? void 0 : data.bitmap) == null ? void 0 : _a2.close();
                  }
                  __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              _objs = new WeakMap();
              _ensureObj = new WeakSet();
              ensureObj_fn = function(objId) {
                const obj = __privateGet(this, _objs)[objId];
                if (obj) {
                  return obj;
                }
                return __privateGet(this, _objs)[objId] = {
                  capability: new _util.PromiseCapability(),
                  data: null
                };
              };
              class RenderTask {
                constructor(internalRenderTask) {
                  __privateAdd(this, _internalRenderTask, null);
                  __privateSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return __privateGet(this, _internalRenderTask).capability.promise;
                }
                cancel(extraDelay = 0) {
                  __privateGet(this, _internalRenderTask).cancel(null, extraDelay);
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = __privateGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = __privateGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap == null ? void 0 : annotationCanvasMap.size) > 0;
                }
              }
              _internalRenderTask = new WeakMap();
              exports.RenderTask = RenderTask;
              const _InternalRenderTask = class {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  annotationCanvasMap,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  filterFactory,
                  useRequestAnimationFrame = false,
                  pdfBug = false,
                  pageColors = null
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.filterFactory = filterFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = new _util.PromiseCapability();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  var _a2, _b;
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && ((_a2 = globalThis.StepperManager) == null ? void 0 : _a2.enabled)) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig
                  }, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  (_b = this.graphicsReadyCallback) == null ? void 0 : _b.call(this);
                }
                cancel(error = null, extraDelay = 0) {
                  var _a2;
                  this.running = false;
                  this.cancelled = true;
                  (_a2 = this.gfx) == null ? void 0 : _a2.endDrawing();
                  if (this._canvas) {
                    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
                }
                operatorListChanged() {
                  var _a2;
                  if (!this.graphicsReady) {
                    this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                    return;
                  }
                  (_a2 = this.stepper) == null ? void 0 : _a2.updateOperatorList(this.operatorList);
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing(this.pageColors);
                      if (this._canvas) {
                        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              };
              let InternalRenderTask = _InternalRenderTask;
              _canvasInUse = new WeakMap();
              __privateAdd(InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
              const version = "3.8.162";
              exports.version = version;
              const build = "2c74323e3";
              exports.build = build;
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _modified, _storage, _setModified, setModified_fn, _serializable;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SerializableEmpty = exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _murmurhash = __w_pdfjs_require__2(8);
              const SerializableEmpty = Object.freeze({
                map: null,
                hash: "",
                transfers: void 0
              });
              exports2.SerializableEmpty = SerializableEmpty;
              class AnnotationStorage {
                constructor() {
                  __privateAdd(this, _setModified);
                  __privateAdd(this, _modified, false);
                  __privateAdd(this, _storage, /* @__PURE__ */ new Map());
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value = __privateGet(this, _storage).get(key);
                  if (value === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value);
                }
                getRawValue(key) {
                  return __privateGet(this, _storage).get(key);
                }
                remove(key) {
                  __privateGet(this, _storage).delete(key);
                  if (__privateGet(this, _storage).size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value of __privateGet(this, _storage).values()) {
                      if (value instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value) {
                  const obj = __privateGet(this, _storage).get(key);
                  let modified = false;
                  if (obj !== void 0) {
                    for (const [entry, val] of Object.entries(value)) {
                      if (obj[entry] !== val) {
                        modified = true;
                        obj[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    __privateGet(this, _storage).set(key, value);
                  }
                  if (modified) {
                    __privateMethod(this, _setModified, setModified_fn).call(this);
                  }
                  if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value.constructor._type);
                  }
                }
                has(key) {
                  return __privateGet(this, _storage).has(key);
                }
                getAll() {
                  return __privateGet(this, _storage).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _storage)) : null;
                }
                setAll(obj) {
                  for (const [key, val] of Object.entries(obj)) {
                    this.setValue(key, val);
                  }
                }
                get size() {
                  return __privateGet(this, _storage).size;
                }
                resetModified() {
                  if (__privateGet(this, _modified)) {
                    __privateSet(this, _modified, false);
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (__privateGet(this, _storage).size === 0) {
                    return SerializableEmpty;
                  }
                  const map = /* @__PURE__ */ new Map(), hash = new _murmurhash.MurmurHash3_64(), transfers = [];
                  for (const [key, val] of __privateGet(this, _storage)) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;
                    if (serialized) {
                      map.set(key, serialized);
                      hash.update(`${key}:${JSON.stringify(serialized)}`);
                      if (serialized.bitmap) {
                        transfers.push(serialized.bitmap);
                      }
                    }
                  }
                  return map.size > 0 ? {
                    map,
                    hash: hash.hexdigest(),
                    transfers
                  } : SerializableEmpty;
                }
              }
              _modified = new WeakMap();
              _storage = new WeakMap();
              _setModified = new WeakSet();
              setModified_fn = function() {
                if (!__privateGet(this, _modified)) {
                  __privateSet(this, _modified, true);
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              };
              exports2.AnnotationStorage = AnnotationStorage;
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  __privateAdd(this, _serializable, void 0);
                  const {
                    map,
                    hash,
                    transfers
                  } = parent.serializable;
                  const clone = structuredClone(map, transfers ? {
                    transfer: transfers
                  } : null);
                  __privateSet(this, _serializable, {
                    map: clone,
                    hash,
                    transfers
                  });
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return __privateGet(this, _serializable);
                }
              }
              _serializable = new WeakMap();
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 4 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundFocusin, _boundFocusout, _hasBeenSelected, _isEditing, _isInEditMode, _zIndex;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(5);
              var _util2 = __w_pdfjs_require__2(1);
              const _AnnotationEditor = class {
                constructor(parameters) {
                  __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                  __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                  __privateAdd(this, _hasBeenSelected, false);
                  __privateAdd(this, _isEditing, false);
                  __privateAdd(this, _isInEditMode, false);
                  __publicField(this, "_uiManager", null);
                  __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                  if (this.constructor === _AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  this._uiManager = parameters.uiManager;
                  this.annotationElementId = null;
                  const {
                    rotation,
                    rawDims: {
                      pageWidth,
                      pageHeight,
                      pageX,
                      pageY
                    }
                  } = this.parent.viewport;
                  this.rotation = rotation;
                  this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
                  this.pageDimensions = [pageWidth, pageHeight];
                  this.pageTranslation = [pageX, pageY];
                  const [width, height] = this.parentDimensions;
                  this.x = parameters.x / width;
                  this.y = parameters.y / height;
                  this.isAttachedToDOM = false;
                  this.deleted = false;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                static deleteAnnotationElement(editor) {
                  const fakeEditor = new FakeEditor({
                    id: editor.parent.getNextId(),
                    parent: editor.parent,
                    uiManager: editor._uiManager
                  });
                  fakeEditor.annotationElementId = editor.annotationElementId;
                  fakeEditor.deleted = true;
                  fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
                }
                addCommands(params) {
                  this._uiManager.addCommands(params);
                }
                get currentLayer() {
                  return this._uiManager.currentLayer;
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = __privateGet(this, _zIndex);
                }
                setParent(parent) {
                  if (parent !== null) {
                    this.pageIndex = parent.pageIndex;
                    this.pageDimensions = parent.pageDimensions;
                  }
                  this.parent = parent;
                }
                focusin(event) {
                  if (!__privateGet(this, _hasBeenSelected)) {
                    this.parent.setSelected(this);
                  } else {
                    __privateSet(this, _hasBeenSelected, false);
                  }
                }
                focusout(event) {
                  var _a;
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target == null ? void 0 : target.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!((_a = this.parent) == null ? void 0 : _a.isMultipleSelection)) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.addToAnnotationStorage();
                }
                addToAnnotationStorage() {
                  this._uiManager.addToAnnotationStorage(this);
                }
                dragstart(event) {
                  const rect = this.parent.div.getBoundingClientRect();
                  this.startX = event.clientX - rect.x;
                  this.startY = event.clientY - rect.y;
                  event.dataTransfer.setData("text/plain", this.id);
                  event.dataTransfer.effectAllowed = "move";
                }
                setAt(x, y, tx, ty) {
                  const [width, height] = this.parentDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x + tx) / width;
                  this.y = (y + ty) / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                translate(x, y) {
                  const [width, height] = this.parentDimensions;
                  [x, y] = this.screenToPageTranslation(x, y);
                  this.x += x / width;
                  this.y += y / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                screenToPageTranslation(x, y) {
                  switch (this.parentRotation) {
                    case 90:
                      return [y, -x];
                    case 180:
                      return [-x, -y];
                    case 270:
                      return [-y, x];
                    default:
                      return [x, y];
                  }
                }
                get parentScale() {
                  return this._uiManager.viewParameters.realScale;
                }
                get parentRotation() {
                  return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
                }
                get parentDimensions() {
                  const {
                    realScale
                  } = this._uiManager.viewParameters;
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  return [pageWidth * realScale, pageHeight * realScale];
                }
                setDims(width, height) {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.div.style.width = `${100 * width / parentWidth}%`;
                  this.div.style.height = `${100 * height / parentHeight}%`;
                }
                fixDims() {
                  const {
                    style
                  } = this.div;
                  const {
                    height,
                    width
                  } = style;
                  const widthPercent = width.endsWith("%");
                  const heightPercent = height.endsWith("%");
                  if (widthPercent && heightPercent) {
                    return;
                  }
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  if (!widthPercent) {
                    style.width = `${100 * parseFloat(width) / parentWidth}%`;
                  }
                  if (!heightPercent) {
                    style.height = `${100 * parseFloat(height) / parentHeight}%`;
                  }
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                  __privateSet(this, _hasBeenSelected, true);
                }
                getRect(tx, ty) {
                  const scale = this.parentScale;
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  const [pageX, pageY] = this.pageTranslation;
                  const shiftX = tx / scale;
                  const shiftY = ty / scale;
                  const x = this.x * pageWidth;
                  const y = this.y * pageHeight;
                  const width = this.width * pageWidth;
                  const height = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
                    case 90:
                      return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
                    case 180:
                      return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
                    case 270:
                      return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x2, y2] = rect;
                  const width = x2 - x1;
                  const height = y2 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y2, width, height];
                    case 90:
                      return [x1, pageHeight - y1, height, width];
                    case 180:
                      return [x2, pageHeight - y1, width, height];
                    case 270:
                      return [x2, pageHeight - y2, height, width];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  __privateSet(this, _isInEditMode, true);
                }
                disableEditMode() {
                  __privateSet(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return __privateGet(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  var _a, _b;
                  (_a = this.div) == null ? void 0 : _a.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  (_b = this.div) == null ? void 0 : _b.addEventListener("focusout", __privateGet(this, _boundFocusout));
                }
                serialize(_isForCopying = false) {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent, uiManager) {
                  const editor = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId(),
                    uiManager
                  });
                  editor.rotation = data.rotation;
                  const [pageWidth, pageHeight] = editor.pageDimensions;
                  const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                  editor.x = x / pageWidth;
                  editor.y = y / pageHeight;
                  editor.width = width / pageWidth;
                  editor.height = height / pageHeight;
                  return editor;
                }
                remove() {
                  this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.parent.remove(this);
                }
                select() {
                  var _a;
                  (_a = this.div) == null ? void 0 : _a.classList.add("selectedEditor");
                }
                unselect() {
                  var _a;
                  (_a = this.div) == null ? void 0 : _a.classList.remove("selectedEditor");
                }
                updateParams(type, value) {
                }
                disableEditing() {
                }
                enableEditing() {
                }
                get propertiesToUpdate() {
                  return {};
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return __privateGet(this, _isEditing);
                }
                set isEditing(value) {
                  __privateSet(this, _isEditing, value);
                  if (value) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
              };
              let AnnotationEditor = _AnnotationEditor;
              _boundFocusin = new WeakMap();
              _boundFocusout = new WeakMap();
              _hasBeenSelected = new WeakMap();
              _isEditing = new WeakMap();
              _isInEditMode = new WeakMap();
              _zIndex = new WeakMap();
              __publicField(AnnotationEditor, "_colorManager", new _tools.ColorManager());
              __publicField(AnnotationEditor, "_zIndex", 1);
              exports2.AnnotationEditor = AnnotationEditor;
              class FakeEditor extends AnnotationEditor {
                constructor(params) {
                  super(params);
                  this.annotationElementId = params.annotationElementId;
                  this.deleted = true;
                }
                serialize() {
                  return {
                    id: this.annotationElementId,
                    deleted: true,
                    pageIndex: this.pageIndex
                  };
                }
              }
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _id, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _activeEditor, _allEditors, _allLayers, _annotationStorage, _commandManager, _currentPageIndex, _deletedAnnotationsElementIds, _editorTypes, _editorsToRescale, _eventBus, _idManager, _isEnabled, _mode, _selectedEditors, _boundCopy, _boundCut, _boundPaste, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _boundOnScaleChanging, _boundOnRotationChanging, _previousStates, _container, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _addCopyPasteListeners, addCopyPasteListeners_fn, _removeCopyPasteListeners, removeCopyPasteListeners_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              function bindEvents(obj, element, names) {
                for (const name of names) {
                  element.addEventListener(name, obj[name].bind(obj));
                }
              }
              function opacityToHex(opacity) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
              }
              class IdManager {
                constructor() {
                  __privateAdd(this, _id, 0);
                }
                getId() {
                  return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
                }
              }
              _id = new WeakMap();
              class CommandManager {
                constructor(maxSize = 128) {
                  __privateAdd(this, _commands, []);
                  __privateAdd(this, _locked, false);
                  __privateAdd(this, _maxSize, void 0);
                  __privateAdd(this, _position, -1);
                  __privateSet(this, _maxSize, maxSize);
                }
                add({
                  cmd,
                  undo,
                  mustExec,
                  type = NaN,
                  overwriteIfSameType = false,
                  keepUndo = false
                }) {
                  if (mustExec) {
                    cmd();
                  }
                  if (__privateGet(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type
                  };
                  if (__privateGet(this, _position) === -1) {
                    if (__privateGet(this, _commands).length > 0) {
                      __privateGet(this, _commands).length = 0;
                    }
                    __privateSet(this, _position, 0);
                    __privateGet(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type) {
                    if (keepUndo) {
                      save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                    }
                    __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                    return;
                  }
                  const next = __privateGet(this, _position) + 1;
                  if (next === __privateGet(this, _maxSize)) {
                    __privateGet(this, _commands).splice(0, 1);
                  } else {
                    __privateSet(this, _position, next);
                    if (next < __privateGet(this, _commands).length) {
                      __privateGet(this, _commands).splice(next);
                    }
                  }
                  __privateGet(this, _commands).push(save);
                }
                undo() {
                  if (__privateGet(this, _position) === -1) {
                    return;
                  }
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                  __privateSet(this, _locked, false);
                  __privateSet(this, _position, __privateGet(this, _position) - 1);
                }
                redo() {
                  if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                    __privateSet(this, _position, __privateGet(this, _position) + 1);
                    __privateSet(this, _locked, true);
                    __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                    __privateSet(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return __privateGet(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
                }
                destroy() {
                  __privateSet(this, _commands, null);
                }
              }
              _commands = new WeakMap();
              _locked = new WeakMap();
              _maxSize = new WeakMap();
              _position = new WeakMap();
              exports2.CommandManager = CommandManager;
              class KeyboardManager {
                constructor(callbacks) {
                  __privateAdd(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  for (const [keys, callback, bubbles = false] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), {
                          callback,
                          bubbles
                        });
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, {
                          callback,
                          bubbles
                        });
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                exec(self2, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const info = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                  if (!info) {
                    return;
                  }
                  const {
                    callback,
                    bubbles
                  } = info;
                  callback.bind(self2)();
                  if (!bubbles) {
                    event.stopPropagation();
                    event.preventDefault();
                  }
                }
              }
              _serialize = new WeakSet();
              serialize_fn = function(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str = this.buffer.join("+");
                this.buffer.length = 0;
                return str;
              };
              exports2.KeyboardManager = KeyboardManager;
              const _ColorManager = class {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color) {
                  const rgb = (0, _display_utils2.getRGB)(color);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb;
                  }
                  for (const [name, RGB] of this._colors) {
                    if (RGB.every((x, i) => x === rgb[i])) {
                      return _ColorManager._colorsMapping.get(name);
                    }
                  }
                  return rgb;
                }
                getHexCode(name) {
                  const rgb = this._colors.get(name);
                  if (!rgb) {
                    return name;
                  }
                  return _util2.Util.makeHexColor(...rgb);
                }
              };
              let ColorManager = _ColorManager;
              __publicField(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              exports2.ColorManager = ColorManager;
              const _AnnotationEditorUIManager = class {
                constructor(container, eventBus, annotationStorage) {
                  __privateAdd(this, _addKeyboardManager);
                  __privateAdd(this, _removeKeyboardManager);
                  __privateAdd(this, _addCopyPasteListeners);
                  __privateAdd(this, _removeCopyPasteListeners);
                  __privateAdd(this, _dispatchUpdateStates);
                  __privateAdd(this, _dispatchUpdateUI);
                  __privateAdd(this, _enableAll);
                  __privateAdd(this, _disableAll);
                  __privateAdd(this, _addEditorToLayer);
                  __privateAdd(this, _isEmpty);
                  __privateAdd(this, _selectEditors);
                  __privateAdd(this, _activeEditor, null);
                  __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                  __privateAdd(this, _annotationStorage, null);
                  __privateAdd(this, _commandManager, new CommandManager());
                  __privateAdd(this, _currentPageIndex, 0);
                  __privateAdd(this, _deletedAnnotationsElementIds, /* @__PURE__ */ new Set());
                  __privateAdd(this, _editorTypes, null);
                  __privateAdd(this, _editorsToRescale, /* @__PURE__ */ new Set());
                  __privateAdd(this, _eventBus, null);
                  __privateAdd(this, _idManager, new IdManager());
                  __privateAdd(this, _isEnabled, false);
                  __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                  __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                  __privateAdd(this, _boundCopy, this.copy.bind(this));
                  __privateAdd(this, _boundCut, this.cut.bind(this));
                  __privateAdd(this, _boundPaste, this.paste.bind(this));
                  __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                  __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                  __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                  __privateAdd(this, _boundOnScaleChanging, this.onScaleChanging.bind(this));
                  __privateAdd(this, _boundOnRotationChanging, this.onRotationChanging.bind(this));
                  __privateAdd(this, _previousStates, {
                    isEditing: false,
                    isEmpty: true,
                    hasSomethingToUndo: false,
                    hasSomethingToRedo: false,
                    hasSelectedEditor: false
                  });
                  __privateAdd(this, _container, null);
                  __privateSet(this, _container, container);
                  __privateSet(this, _eventBus, eventBus);
                  __privateGet(this, _eventBus)._on("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                  __privateGet(this, _eventBus)._on("scalechanging", __privateGet(this, _boundOnScaleChanging));
                  __privateGet(this, _eventBus)._on("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                  __privateSet(this, _annotationStorage, annotationStorage);
                  this.viewParameters = {
                    realScale: _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: 0
                  };
                }
                static get _keyboardManager() {
                  return (0, _util2.shadow)(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], _AnnotationEditorUIManager.prototype.selectAll], [["ctrl+z", "mac+meta+z"], _AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], _AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], _AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], _AnnotationEditorUIManager.prototype.unselectAll]]));
                }
                destroy() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateGet(this, _eventBus)._off("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                  __privateGet(this, _eventBus)._off("scalechanging", __privateGet(this, _boundOnScaleChanging));
                  __privateGet(this, _eventBus)._off("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  __privateGet(this, _allLayers).clear();
                  __privateGet(this, _allEditors).clear();
                  __privateGet(this, _editorsToRescale).clear();
                  __privateSet(this, _activeEditor, null);
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _commandManager).destroy();
                }
                onPageChanging({
                  pageNumber
                }) {
                  __privateSet(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  __privateGet(this, _container).focus();
                }
                addShouldRescale(editor) {
                  __privateGet(this, _editorsToRescale).add(editor);
                }
                removeShouldRescale(editor) {
                  __privateGet(this, _editorsToRescale).delete(editor);
                }
                onScaleChanging({
                  scale
                }) {
                  this.commitOrRemove();
                  this.viewParameters.realScale = scale * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS;
                  for (const editor of __privateGet(this, _editorsToRescale)) {
                    editor.onScaleChanging();
                  }
                }
                onRotationChanging({
                  pagesRotation
                }) {
                  this.commitOrRemove();
                  this.viewParameters.rotation = pagesRotation;
                }
                addToAnnotationStorage(editor) {
                  if (!editor.isEmpty() && __privateGet(this, _annotationStorage) && !__privateGet(this, _annotationStorage).has(editor.id)) {
                    __privateGet(this, _annotationStorage).setValue(editor.id, editor);
                  }
                }
                copy(event) {
                  event.preventDefault();
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [];
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    const serialized = editor.serialize(true);
                    if (serialized) {
                      editors.push(serialized);
                    }
                  }
                  if (editors.length === 0) {
                    return;
                  }
                  event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
                }
                cut(event) {
                  this.copy(event);
                  this.delete();
                }
                paste(event) {
                  event.preventDefault();
                  let data = event.clipboardData.getData("application/pdfjs");
                  if (!data) {
                    return;
                  }
                  try {
                    data = JSON.parse(data);
                  } catch (ex) {
                    (0, _util2.warn)(`paste: "${ex.message}".`);
                    return;
                  }
                  if (!Array.isArray(data)) {
                    return;
                  }
                  this.unselectAll();
                  const layer = __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                  try {
                    const newEditors = [];
                    for (const editor of data) {
                      const deserializedEditor = layer.deserialize(editor);
                      if (!deserializedEditor) {
                        return;
                      }
                      newEditors.push(deserializedEditor);
                    }
                    const cmd = () => {
                      for (const editor of newEditors) {
                        __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                      }
                      __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                    };
                    const undo = () => {
                      for (const editor of newEditors) {
                        editor.remove();
                      }
                    };
                    this.addCommands({
                      cmd,
                      undo,
                      mustExec: true
                    });
                  } catch (ex) {
                    (0, _util2.warn)(`paste: "${ex.message}".`);
                  }
                }
                keydown(event) {
                  var _a;
                  if (!((_a = this.getActive()) == null ? void 0 : _a.shouldGetKeyboardEvents())) {
                    _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                    __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false
                    });
                  } else {
                    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                    __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: false
                    });
                  }
                }
                registerEditorTypes(types) {
                  if (__privateGet(this, _editorTypes)) {
                    return;
                  }
                  __privateSet(this, _editorTypes, types);
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return __privateGet(this, _idManager).getId();
                }
                get currentLayer() {
                  return __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                }
                get currentPageIndex() {
                  return __privateGet(this, _currentPageIndex);
                }
                addLayer(layer) {
                  __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                  if (__privateGet(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  __privateGet(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode) {
                  __privateSet(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    __privateMethod(this, _disableAll, disableAll_fn).call(this);
                  } else {
                    this.setEditingState(true);
                    __privateMethod(this, _enableAll, enableAll_fn).call(this);
                    for (const layer of __privateGet(this, _allLayers).values()) {
                      layer.updateMode(mode);
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === __privateGet(this, _mode)) {
                    return;
                  }
                  __privateGet(this, _eventBus).dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type, value) {
                  if (!__privateGet(this, _editorTypes)) {
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.updateParams(type, value);
                  }
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    editorType.updateDefaultParams(type, value);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    if (editor.pageIndex === pageIndex) {
                      editors.push(editor);
                    }
                  }
                  return editors;
                }
                getEditor(id) {
                  return __privateGet(this, _allEditors).get(id);
                }
                addEditor(editor) {
                  __privateGet(this, _allEditors).set(editor.id, editor);
                }
                removeEditor(editor) {
                  var _a;
                  __privateGet(this, _allEditors).delete(editor.id);
                  this.unselect(editor);
                  if (!editor.annotationElementId || !__privateGet(this, _deletedAnnotationsElementIds).has(editor.annotationElementId)) {
                    (_a = __privateGet(this, _annotationStorage)) == null ? void 0 : _a.remove(editor.id);
                  }
                }
                addDeletedAnnotationElement(editor) {
                  __privateGet(this, _deletedAnnotationsElementIds).add(editor.annotationElementId);
                  editor.deleted = true;
                }
                isDeletedAnnotationElement(annotationElementId) {
                  return __privateGet(this, _deletedAnnotationsElementIds).has(annotationElementId);
                }
                removeDeletedAnnotationElement(editor) {
                  __privateGet(this, _deletedAnnotationsElementIds).delete(editor.annotationElementId);
                  editor.deleted = false;
                }
                setActiveEditor(editor) {
                  if (__privateGet(this, _activeEditor) === editor) {
                    return;
                  }
                  __privateSet(this, _activeEditor, editor);
                  if (editor) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  }
                }
                toggleSelected(editor) {
                  if (__privateGet(this, _selectedEditors).has(editor)) {
                    __privateGet(this, _selectedEditors).delete(editor);
                    editor.unselect();
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor) {
                  for (const ed of __privateGet(this, _selectedEditors)) {
                    if (ed !== editor) {
                      ed.unselect();
                    }
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor) {
                  return __privateGet(this, _selectedEditors).has(editor);
                }
                unselect(editor) {
                  editor.unselect();
                  __privateGet(this, _selectedEditors).delete(editor);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return __privateGet(this, _selectedEditors).size !== 0;
                }
                undo() {
                  __privateGet(this, _commandManager).undo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                redo() {
                  __privateGet(this, _commandManager).redo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                addCommands(params) {
                  __privateGet(this, _commandManager).add(params);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                delete() {
                  this.commitOrRemove();
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor of editors) {
                      editor.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor of editors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                commitOrRemove() {
                  var _a;
                  (_a = __privateGet(this, _activeEditor)) == null ? void 0 : _a.commitOrRemove();
                }
                selectAll() {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.commit();
                  }
                  __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
                }
                unselectAll() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (__privateGet(this, _selectedEditors).size === 0) {
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.unselect();
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: false
                  });
                }
                isActive(editor) {
                  return __privateGet(this, _activeEditor) === editor;
                }
                getActive() {
                  return __privateGet(this, _activeEditor);
                }
                getMode() {
                  return __privateGet(this, _mode);
                }
              };
              let AnnotationEditorUIManager = _AnnotationEditorUIManager;
              _activeEditor = new WeakMap();
              _allEditors = new WeakMap();
              _allLayers = new WeakMap();
              _annotationStorage = new WeakMap();
              _commandManager = new WeakMap();
              _currentPageIndex = new WeakMap();
              _deletedAnnotationsElementIds = new WeakMap();
              _editorTypes = new WeakMap();
              _editorsToRescale = new WeakMap();
              _eventBus = new WeakMap();
              _idManager = new WeakMap();
              _isEnabled = new WeakMap();
              _mode = new WeakMap();
              _selectedEditors = new WeakMap();
              _boundCopy = new WeakMap();
              _boundCut = new WeakMap();
              _boundPaste = new WeakMap();
              _boundKeydown = new WeakMap();
              _boundOnEditingAction = new WeakMap();
              _boundOnPageChanging = new WeakMap();
              _boundOnScaleChanging = new WeakMap();
              _boundOnRotationChanging = new WeakMap();
              _previousStates = new WeakMap();
              _container = new WeakMap();
              _addKeyboardManager = new WeakSet();
              addKeyboardManager_fn = function() {
                __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _removeKeyboardManager = new WeakSet();
              removeKeyboardManager_fn = function() {
                __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _addCopyPasteListeners = new WeakSet();
              addCopyPasteListeners_fn = function() {
                document.addEventListener("copy", __privateGet(this, _boundCopy));
                document.addEventListener("cut", __privateGet(this, _boundCut));
                document.addEventListener("paste", __privateGet(this, _boundPaste));
              };
              _removeCopyPasteListeners = new WeakSet();
              removeCopyPasteListeners_fn = function() {
                document.removeEventListener("copy", __privateGet(this, _boundCopy));
                document.removeEventListener("cut", __privateGet(this, _boundCut));
                document.removeEventListener("paste", __privateGet(this, _boundPaste));
              };
              _dispatchUpdateStates = new WeakSet();
              dispatchUpdateStates_fn = function(details) {
                const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
                if (hasChanged) {
                  __privateGet(this, _eventBus).dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(__privateGet(this, _previousStates), details)
                  });
                }
              };
              _dispatchUpdateUI = new WeakSet();
              dispatchUpdateUI_fn = function(details) {
                __privateGet(this, _eventBus).dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              };
              _enableAll = new WeakSet();
              enableAll_fn = function() {
                if (!__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, true);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              };
              _disableAll = new WeakSet();
              disableAll_fn = function() {
                this.unselectAll();
                if (__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, false);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              };
              _addEditorToLayer = new WeakSet();
              addEditorToLayer_fn = function(editor) {
                const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor);
                } else {
                  this.addEditor(editor);
                }
              };
              _isEmpty = new WeakSet();
              isEmpty_fn = function() {
                if (__privateGet(this, _allEditors).size === 0) {
                  return true;
                }
                if (__privateGet(this, _allEditors).size === 1) {
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    return editor.isEmpty();
                  }
                }
                return false;
              };
              _selectEditors = new WeakSet();
              selectEditors_fn = function(editors) {
                __privateGet(this, _selectedEditors).clear();
                for (const editor of editors) {
                  if (editor.isEmpty()) {
                    continue;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                }
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              };
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var __cache, __defs, _docId, _document, _hcmFilter, _hcmKey, _hcmUrl, _hcmHighlightFilter, _hcmHighlightKey, _hcmHighlightUrl, _id, _cache, cache_get, _defs, defs_get, _addGrayConversion, addGrayConversion_fn, _createFilter, createFilter_fn, _appendFeFunc, appendFeFunc_fn, _addTransferMapConversion, addTransferMapConversion_fn, _getRGB, getRGB_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMFilterFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = exports2.AnnotationPrefix = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              exports2.setLayerDimensions = setLayerDimensions;
              var _base_factory = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              const SVG_NS = "http://www.w3.org/2000/svg";
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
              const _PixelsPerInch = class {
              };
              let PixelsPerInch = _PixelsPerInch;
              __publicField(PixelsPerInch, "CSS", 96);
              __publicField(PixelsPerInch, "PDF", 72);
              __publicField(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
              exports2.PixelsPerInch = PixelsPerInch;
              class DOMFilterFactory extends _base_factory.BaseFilterFactory {
                constructor({
                  docId,
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  __privateAdd(this, _cache);
                  __privateAdd(this, _defs);
                  __privateAdd(this, _addGrayConversion);
                  __privateAdd(this, _createFilter);
                  __privateAdd(this, _appendFeFunc);
                  __privateAdd(this, _addTransferMapConversion);
                  __privateAdd(this, _getRGB);
                  __privateAdd(this, __cache, void 0);
                  __privateAdd(this, __defs, void 0);
                  __privateAdd(this, _docId, void 0);
                  __privateAdd(this, _document, void 0);
                  __privateAdd(this, _hcmFilter, void 0);
                  __privateAdd(this, _hcmKey, void 0);
                  __privateAdd(this, _hcmUrl, void 0);
                  __privateAdd(this, _hcmHighlightFilter, void 0);
                  __privateAdd(this, _hcmHighlightKey, void 0);
                  __privateAdd(this, _hcmHighlightUrl, void 0);
                  __privateAdd(this, _id, 0);
                  __privateSet(this, _docId, docId);
                  __privateSet(this, _document, ownerDocument);
                }
                addFilter(maps) {
                  if (!maps) {
                    return "none";
                  }
                  let value = __privateGet(this, _cache, cache_get).get(maps);
                  if (value) {
                    return value;
                  }
                  let tableR, tableG, tableB, key;
                  if (maps.length === 1) {
                    const mapR = maps[0];
                    const buffer = new Array(256);
                    for (let i = 0; i < 256; i++) {
                      buffer[i] = mapR[i] / 255;
                    }
                    key = tableR = tableG = tableB = buffer.join(",");
                  } else {
                    const [mapR, mapG, mapB] = maps;
                    const bufferR = new Array(256);
                    const bufferG = new Array(256);
                    const bufferB = new Array(256);
                    for (let i = 0; i < 256; i++) {
                      bufferR[i] = mapR[i] / 255;
                      bufferG[i] = mapG[i] / 255;
                      bufferB[i] = mapB[i] / 255;
                    }
                    tableR = bufferR.join(",");
                    tableG = bufferG.join(",");
                    tableB = bufferB.join(",");
                    key = `${tableR}${tableG}${tableB}`;
                  }
                  value = __privateGet(this, _cache, cache_get).get(key);
                  if (value) {
                    __privateGet(this, _cache, cache_get).set(maps, value);
                    return value;
                  }
                  const id = `g_${__privateGet(this, _docId)}_transfer_map_${__privateWrapper(this, _id)._++}`;
                  const url = `url(#${id})`;
                  __privateGet(this, _cache, cache_get).set(maps, url);
                  __privateGet(this, _cache, cache_get).set(key, url);
                  const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, tableR, tableG, tableB, filter);
                  return url;
                }
                addHCMFilter(fgColor, bgColor) {
                  var _a;
                  const key = `${fgColor}-${bgColor}`;
                  if (__privateGet(this, _hcmKey) === key) {
                    return __privateGet(this, _hcmUrl);
                  }
                  __privateSet(this, _hcmKey, key);
                  __privateSet(this, _hcmUrl, "none");
                  (_a = __privateGet(this, _hcmFilter)) == null ? void 0 : _a.remove();
                  if (!fgColor || !bgColor) {
                    return __privateGet(this, _hcmUrl);
                  }
                  const fgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, fgColor);
                  fgColor = _util2.Util.makeHexColor(...fgRGB);
                  const bgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, bgColor);
                  bgColor = _util2.Util.makeHexColor(...bgRGB);
                  __privateGet(this, _defs, defs_get).style.color = "";
                  if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
                    return __privateGet(this, _hcmUrl);
                  }
                  const map = new Array(256);
                  for (let i = 0; i <= 255; i++) {
                    const x = i / 255;
                    map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                  }
                  const table = map.join(",");
                  const id = `g_${__privateGet(this, _docId)}_hcm_filter`;
                  const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, table, table, table, filter);
                  __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                  const getSteps = (c, n) => {
                    const start = fgRGB[c] / 255;
                    const end = bgRGB[c] / 255;
                    const arr = new Array(n + 1);
                    for (let i = 0; i <= n; i++) {
                      arr[i] = start + i / n * (end - start);
                    }
                    return arr.join(",");
                  };
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
                  __privateSet(this, _hcmUrl, `url(#${id})`);
                  return __privateGet(this, _hcmUrl);
                }
                addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                  var _a;
                  const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
                  if (__privateGet(this, _hcmHighlightKey) === key) {
                    return __privateGet(this, _hcmHighlightUrl);
                  }
                  __privateSet(this, _hcmHighlightKey, key);
                  __privateSet(this, _hcmHighlightUrl, "none");
                  (_a = __privateGet(this, _hcmHighlightFilter)) == null ? void 0 : _a.remove();
                  if (!fgColor || !bgColor) {
                    return __privateGet(this, _hcmHighlightUrl);
                  }
                  const [fgRGB, bgRGB] = [fgColor, bgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                  let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
                  let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
                  let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                  if (bgGray < fgGray) {
                    [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
                  }
                  __privateGet(this, _defs, defs_get).style.color = "";
                  const getSteps = (fg, bg, n) => {
                    const arr = new Array(256);
                    const step = (bgGray - fgGray) / n;
                    const newStart = fg / 255;
                    const newStep = (bg - fg) / (255 * n);
                    let prev = 0;
                    for (let i = 0; i <= n; i++) {
                      const k = Math.round(fgGray + i * step);
                      const value = newStart + i * newStep;
                      for (let j = prev; j <= k; j++) {
                        arr[j] = value;
                      }
                      prev = k + 1;
                    }
                    for (let i = prev; i < 256; i++) {
                      arr[i] = arr[prev - 1];
                    }
                    return arr.join(",");
                  };
                  const id = `g_${__privateGet(this, _docId)}_hcm_highlight_filter`;
                  const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                  __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                  __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
                  __privateSet(this, _hcmHighlightUrl, `url(#${id})`);
                  return __privateGet(this, _hcmHighlightUrl);
                }
                destroy(keepHCM = false) {
                  if (keepHCM && (__privateGet(this, _hcmUrl) || __privateGet(this, _hcmHighlightUrl))) {
                    return;
                  }
                  if (__privateGet(this, __defs)) {
                    __privateGet(this, __defs).parentNode.parentNode.remove();
                    __privateSet(this, __defs, null);
                  }
                  if (__privateGet(this, __cache)) {
                    __privateGet(this, __cache).clear();
                    __privateSet(this, __cache, null);
                  }
                  __privateSet(this, _id, 0);
                }
              }
              __cache = new WeakMap();
              __defs = new WeakMap();
              _docId = new WeakMap();
              _document = new WeakMap();
              _hcmFilter = new WeakMap();
              _hcmKey = new WeakMap();
              _hcmUrl = new WeakMap();
              _hcmHighlightFilter = new WeakMap();
              _hcmHighlightKey = new WeakMap();
              _hcmHighlightUrl = new WeakMap();
              _id = new WeakMap();
              _cache = new WeakSet();
              cache_get = function() {
                return __privateGet(this, __cache) || __privateSet(this, __cache, /* @__PURE__ */ new Map());
              };
              _defs = new WeakSet();
              defs_get = function() {
                if (!__privateGet(this, __defs)) {
                  const div = __privateGet(this, _document).createElement("div");
                  const {
                    style
                  } = div;
                  style.visibility = "hidden";
                  style.contain = "strict";
                  style.width = style.height = 0;
                  style.position = "absolute";
                  style.top = style.left = 0;
                  style.zIndex = -1;
                  const svg = __privateGet(this, _document).createElementNS(SVG_NS, "svg");
                  svg.setAttribute("width", 0);
                  svg.setAttribute("height", 0);
                  __privateSet(this, __defs, __privateGet(this, _document).createElementNS(SVG_NS, "defs"));
                  div.append(svg);
                  svg.append(__privateGet(this, __defs));
                  __privateGet(this, _document).body.append(div);
                }
                return __privateGet(this, __defs);
              };
              _addGrayConversion = new WeakSet();
              addGrayConversion_fn = function(filter) {
                const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
                feColorMatrix.setAttribute("type", "matrix");
                feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
                filter.append(feColorMatrix);
              };
              _createFilter = new WeakSet();
              createFilter_fn = function(id) {
                const filter = __privateGet(this, _document).createElementNS(SVG_NS, "filter");
                filter.setAttribute("color-interpolation-filters", "sRGB");
                filter.setAttribute("id", id);
                __privateGet(this, _defs, defs_get).append(filter);
                return filter;
              };
              _appendFeFunc = new WeakSet();
              appendFeFunc_fn = function(feComponentTransfer, func, table) {
                const feFunc = __privateGet(this, _document).createElementNS(SVG_NS, func);
                feFunc.setAttribute("type", "discrete");
                feFunc.setAttribute("tableValues", table);
                feComponentTransfer.append(feFunc);
              };
              _addTransferMapConversion = new WeakSet();
              addTransferMapConversion_fn = function(rTable, gTable, bTable, filter) {
                const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
                filter.append(feComponentTransfer);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncR", rTable);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncG", gTable);
                __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncB", bTable);
              };
              _getRGB = new WeakSet();
              getRGB_fn = function(color) {
                __privateGet(this, _defs, defs_get).style.color = color;
                return getRGB(getComputedStyle(__privateGet(this, _defs, defs_get)).getPropertyValue("color"));
              };
              exports2.DOMFilterFactory = DOMFilterFactory;
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor({
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width, height) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width;
                  canvas.height = height;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url, asTypedArray = false) {
                if (isValidFetchUrl(url, document.baseURI)) {
                  const response = await fetch(url);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type) {
                  return document.createElementNS(SVG_NS, type);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor({
                  viewBox,
                  scale,
                  rotation,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                }) {
                  this.viewBox = viewBox;
                  this.scale = scale;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                    width = (viewBox[3] - viewBox[1]) * scale;
                    height = (viewBox[2] - viewBox[0]) * scale;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                    width = (viewBox[2] - viewBox[0]) * scale;
                    height = (viewBox[3] - viewBox[1]) * scale;
                  }
                  this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                  this.width = width;
                  this.height = height;
                }
                get rawDims() {
                  const {
                    viewBox
                  } = this;
                  return (0, _util2.shadow)(this, "rawDims", {
                    pageWidth: viewBox[2] - viewBox[0],
                    pageHeight: viewBox[3] - viewBox[1],
                    pageX: viewBox[0],
                    pageY: viewBox[1]
                  });
                }
                clone({
                  scale = this.scale,
                  rotation = this.rotation,
                  offsetX = this.offsetX,
                  offsetY = this.offsetY,
                  dontFlip = false
                } = {}) {
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, extraDelay = 0) {
                  super(msg, "RenderingCancelledException");
                  this.extraDelay = extraDelay;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url) {
                const ii = url.length;
                let i = 0;
                while (i < ii && url[i].trim() === "") {
                  i++;
                }
                return url.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url, onlyStripPath = false) {
                if (!onlyStripPath) {
                  [url] = url.split(/[#?]/, 1);
                }
                return url.substring(url.lastIndexOf("/") + 1);
              }
              function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
                if (typeof url !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  __publicField(this, "started", /* @__PURE__ */ Object.create(null));
                  __publicField(this, "times", []);
                }
                time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name}`);
                  }
                  this.started[name] = Date.now();
                }
                timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name}`);
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const {
                    name
                  } of this.times) {
                    longest = Math.max(name.length, longest);
                  }
                  for (const {
                    name,
                    start,
                    end
                  } of this.times) {
                    outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  return protocol === "http:" || protocol === "https:";
                } catch {
                  return false;
                }
              }
              function loadScript(src, removeScriptElement = false) {
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  pdfDateStringRegex || (pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, {
                scale = 1,
                rotation = 0
              }) {
                const {
                  width,
                  height
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale,
                  rotation
                });
              }
              function getRGB(color) {
                if (color.startsWith("#")) {
                  const colorRGB = parseInt(color.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color.startsWith("rgb(")) {
                  return color.slice(4, -1).split(",").map((x) => parseInt(x));
                }
                if (color.startsWith("rgba(")) {
                  return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name of colors.keys()) {
                  span.style.color = name;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f
                } = ctx.getTransform();
                return [a, b, c, d, e, f];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f
                } = ctx.getTransform().invertSelf();
                return [a, b, c, d, e, f];
              }
              function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
                if (viewport instanceof PageViewport) {
                  const {
                    pageWidth,
                    pageHeight
                  } = viewport.rawDims;
                  const {
                    style
                  } = div;
                  const widthStr = `calc(var(--scale-factor) * ${pageWidth}px)`;
                  const heightStr = `calc(var(--scale-factor) * ${pageHeight}px)`;
                  if (!mustFlip || viewport.rotation % 180 === 0) {
                    style.width = widthStr;
                    style.height = heightStr;
                  } else {
                    style.width = heightStr;
                    style.height = widthStr;
                  }
                }
                if (mustRotate) {
                  div.setAttribute("data-main-rotation", viewport.rotation);
                }
              }
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseFilterFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFilterFactory {
                constructor() {
                  if (this.constructor === BaseFilterFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseFilterFactory.");
                  }
                }
                addFilter(maps) {
                  return "none";
                }
                addHCMFilter(fgColor, bgColor) {
                  return "none";
                }
                addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                  return "none";
                }
                destroy(keepHCM = false) {
                }
              }
              exports2.BaseFilterFactory = BaseFilterFactory;
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width, height) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor({
                  baseUrl = null,
                  isCompressed = true
                }) {
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch({
                  name
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                }
                _fetchData(url, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor({
                  baseUrl = null
                }) {
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch({
                  filename
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url = `${this.baseUrl}${filename}`;
                  return this._fetchData(url).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url}`);
                  });
                }
                _fetchData(url) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width, height, skipDimensions = false) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width}px`);
                    svg.setAttribute("height", `${height}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                  return svg;
                }
                createElement(type) {
                  if (typeof type !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type);
                }
                _createSVG(type) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length >> 2;
                  const tailLength = length - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _systemFonts;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(10);
              class FontLoader {
                constructor({
                  ownerDocument = globalThis.document,
                  styleElement = null
                }) {
                  __privateAdd(this, _systemFonts, /* @__PURE__ */ new Set());
                  this._document = ownerDocument;
                  this.nativeFontFaces = /* @__PURE__ */ new Set();
                  this.styleElement = null;
                  this.loadingRequests = [];
                  this.loadTestFontId = 0;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.add(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                removeNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.delete(nativeFontFace);
                  this._document.fonts.delete(nativeFontFace);
                }
                insertRule(rule) {
                  if (!this.styleElement) {
                    this.styleElement = this._document.createElement("style");
                    this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
                  }
                  const styleSheet = this.styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.clear();
                  __privateGet(this, _systemFonts).clear();
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async loadSystemFont(info) {
                  if (!info || __privateGet(this, _systemFonts).has(info.loadedName)) {
                    return;
                  }
                  (0, _util2.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
                  if (this.isFontLoadingAPISupported) {
                    const {
                      loadedName,
                      src,
                      style
                    } = info;
                    const fontFace = new FontFace(loadedName, src, style);
                    this.addNativeFontFace(fontFace);
                    try {
                      await fontFace.load();
                      __privateGet(this, _systemFonts).add(loadedName);
                    } catch {
                      (0, _util2.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
                      this.removeNativeFontFace(fontFace);
                    }
                    return;
                  }
                  (0, _util2.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                }
                async bind(font) {
                  if (font.attached || font.missingFile && !font.systemFontInfo) {
                    return;
                  }
                  font.attached = true;
                  if (font.systemFontInfo) {
                    await this.loadSystemFont(font.systemFontInfo);
                    return;
                  }
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent(font, request);
                    });
                  }
                }
                get isFontLoadingAPISupported() {
                  var _a;
                  const hasFonts = !!((_a = this._document) == null ? void 0 : _a.fonts);
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  let supported = false;
                  if (_is_node2.isNodeJS) {
                    supported = true;
                  } else if (typeof navigator !== "undefined" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
                    supported = true;
                  }
                  return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
                _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;
                    while (loadingRequests.length > 0 && loadingRequests[0].done) {
                      const otherRequest = loadingRequests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }
                  const {
                    loadingRequests
                  } = this;
                  const request = {
                    done: false,
                    complete: completeRequest,
                    callback
                  };
                  loadingRequests.push(request);
                  return request;
                }
                get _loadTestFont() {
                  const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  return (0, _util2.shadow)(this, "_loadTestFont", testFont);
                }
                _prepareFontLoadEvent(font, request) {
                  function int32(data2, offset) {
                    return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                  }
                  function spliceString(s, offset, remove, insert) {
                    const chunk1 = s.substring(0, offset);
                    const chunk2 = s.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }
                  let i, ii;
                  const canvas = this._document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext("2d");
                  let called = 0;
                  function isFontReady(name, callback) {
                    if (++called > 30) {
                      (0, _util2.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }
                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }
                    setTimeout(isFontReady.bind(null, name, callback));
                  }
                  const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                  let data = this._loadTestFont;
                  const COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  const CFF_CHECKSUM_OFFSET = 16;
                  const XXXX_VALUE = 1482184792;
                  let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                  for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                  }
                  if (i < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                  }
                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                  const url = `url(data:font/opentype;base64,${btoa(data)});`;
                  const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                  this.insertRule(rule);
                  const div = this._document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";
                  for (const name of [font.loadedName, loadTestFontId]) {
                    const span = this._document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = name;
                    div.append(span);
                  }
                  this._document.body.append(div);
                  isFontReady(loadTestFontId, () => {
                    div.remove();
                    request.complete();
                  });
                }
              }
              _systemFonts = new WeakMap();
              exports2.FontLoader = FontLoader;
              class FontFaceObject {
                constructor(translatedData, {
                  isEvalSupported = true,
                  disableFontFace = false,
                  ignoreErrors = false,
                  inspectFont = null
                }) {
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._inspectFont = inspectFont;
                }
                createNativeFontFace() {
                  var _a;
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  (_a = this._inspectFont) == null ? void 0 : _a.call(this, this);
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  var _a;
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule;
                  if (!this.cssFontInfo) {
                    rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
                  }
                  (_a = this._inspectFont) == null ? void 0 : _a.call(this, this, url);
                  return rule;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c, size) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c, size) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size, -size];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _restoreInitialState, restoreInitialState_fn, _drawFilter, drawFilter_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _pattern_helper = __w_pdfjs_require__2(12);
              var _image_utils = __w_pdfjs_require__2(13);
              var _is_node2 = __w_pdfjs_require__2(10);
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  destCtx.transform(a, b, c, d, e, f);
                  this.__originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  destCtx.setTransform(a, b, c, d, e, f);
                  this.__originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  destCtx.rotate(angle);
                  this.__originalRotate(angle);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width, height) {
                  destCtx.rect(x, y, width, height);
                  this.__originalRect(x, y, width, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id, width, height) {
                  let canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id) {
                  delete this.cache[id];
                }
                clear() {
                  for (const id in this.cache) {
                    const canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a, b, c, d, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b === 0 && c === 0) {
                  const tlX = destX * a + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  const tlX = destY * c + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a, b);
                const scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width,
                  height
                } = imgData;
                if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width + 1;
                let points = new Uint8Array(width1 * (height + 1));
                let i, j, j0;
                const lineSize = width + 7 & ~7;
                let data = new Uint8Array(lineSize * height), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i = 0; count && i <= height; i++) {
                  let p = i * width1;
                  const end = p + width;
                  while (p < end && !points[p]) {
                    p++;
                  }
                  if (p === end) {
                    continue;
                  }
                  path.moveTo(p % width1, i);
                  const p0 = p;
                  let type = points[p];
                  do {
                    const step = steps[type];
                    do {
                      p += step;
                    } while (!points[p]);
                    const pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type = pp;
                      points[p] = 0;
                    } else {
                      type = pp & 51 * type >> 4;
                      points[p] &= type >> 2 | type << 2;
                    }
                    path.lineTo(p % width1, p / width1 | 0);
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  --i;
                }
                data = null;
                points = null;
                const drawOutline = function(c) {
                  c.save();
                  c.scale(1 / width, -1 / height);
                  c.translate(0, -height);
                  c.fill(path);
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width, height) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = "none";
                  this.startNewPathAndClipBox([0, 0, width, height]);
                }
                clone() {
                  const clone = Object.create(this);
                  clone.clipBox = this.clipBox.slice();
                  return clone;
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
                updatePathMinMax(transform, x, y) {
                  [x, y] = _util2.Util.applyTransform([x, y], transform);
                  this.minX = Math.min(this.minX, x);
                  this.minY = Math.min(this.minY, y);
                  this.maxX = Math.max(this.maxX, x);
                  this.maxY = Math.max(this.maxY, y);
                }
                updateRectMinMax(transform, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform, minMax) {
                  _util2.Util.scaleMinMax(transform, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform, box);
                }
                getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale = _util2.Util.singularValueDecompose2dScale(transform);
                    const xStrokePad = scale[0] * this.lineWidth / 2;
                    const yStrokePad = scale[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                }
              }
              function putBinaryImageData(ctx, imgData) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width + 7 >> 3;
                  const white = 4294967295;
                  const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.convertBlackAndWhiteToRGBA)({
                    src,
                    srcPos,
                    dest,
                    width,
                    height: thisChunkHeight,
                    nonBlackColor: 0
                  }));
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
                for (const property of properties) {
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
                if (!_is_node2.isNodeJS) {
                  ctx.filter = "none";
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length = bytes.length;
                for (let i = 3; i < length; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length = maskData.length;
                const scale = 1 / 255;
                for (let i = 3; i < length; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length = maskData.length;
                for (let i = 3; i < length; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                const scale = _util2.Util.singularValueDecompose2dScale(transform);
                scale[0] = Math.fround(scale[0]);
                scale[1] = Math.fround(scale[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              const _CanvasGraphics = class {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
                  optionalContentConfig,
                  markedContentStack = null
                }, annotationCanvasMap, pageColors) {
                  __privateAdd(this, _restoreInitialState);
                  __privateAdd(this, _drawFilter);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.filterFactory = filterFactory;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = markedContentStack || [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.pageColors = pageColors;
                  this._cachedScaleForStroking = [-1, 0];
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  const savedFillStyle = this.ctx.fillStyle;
                  this.ctx.fillStyle = background || "#ffffff";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.fillStyle = savedFillStyle;
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform(...transform);
                    this.outputScaleX = transform[0];
                    this.outputScaleY = transform[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
                }
                _scaleImage(img, inverseTransform) {
                  const width = img.width;
                  const height = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width,
                    height
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width, height);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width) {
                  if (width !== this.current.lineWidth) {
                    this._cachedScaleForStroking[0] = -1;
                  }
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = value;
                        break;
                      case "ca":
                        this.current.fillAlpha = value;
                        this.ctx.globalAlpha = value;
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        this.current.activeSMask = value ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                        break;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking[0] = -1;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this._cachedScaleForStroking[0] = -1;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        ctx.moveTo(x, y);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x;
                        startY = y;
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x;
                        startY = y;
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x;
                        startY = y;
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x, y);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath = true) {
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath = true) {
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size) {
                  var _a;
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  const typeface = ((_a = fontObj.systemFontInfo) == null ? void 0 : _a.css) || `"${name}", ${fontObj.fallbackName}`;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x, y, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font.missingFile;
                  let addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  if (font.isInvalidPDFjsFont) {
                    const chars = [];
                    let width = 0;
                    for (const glyph of glyphs) {
                      chars.push(glyph.unicode);
                      width += glyph.width;
                    }
                    ctx.fillText(chars.join(""), 0, 0);
                    current.x += width * widthAdvanceScale * textHScale;
                    ctx.restore();
                    this.compose();
                    return void 0;
                  }
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedScaleForStroking[0] = -1;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                          optionalContentConfig: this.optionalContentConfig,
                          markedContentStack: this.markedContentStack
                        });
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r, g, b) {
                  const color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                }
                setFillRGBColor(r, g, b) {
                  const color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                }
                _getPattern(objId, matrix = null) {
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const {
                      width,
                      height
                    } = ctx.canvas;
                    const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group.matrix) {
                    currentCtx.transform(...group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  resetCtxToDefault(this.ctx);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform = transform.slice();
                      transform[4] -= rect[0];
                      transform[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width;
                      rect[3] = height;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context;
                      this.ctx.save();
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                      resetCtxToDefault(this.ctx);
                    } else {
                      resetCtxToDefault(this.ctx);
                      this.ctx.rect(rect[0], rect[1], width, height);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx.restore();
                    __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                    const [x, y] = _util2.Util.applyTransform([0, 0], trans);
                    ctx.drawImage(mask.canvas, x, y);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image of images) {
                    const {
                      data,
                      width,
                      height,
                      transform
                    } = image;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                applyTransferMapsToCanvas(ctx) {
                  if (this.current.transferMaps !== "none") {
                    ctx.filter = this.current.transferMaps;
                    ctx.drawImage(ctx.canvas, 0, 0);
                    ctx.filter = "none";
                  }
                  return ctx.canvas;
                }
                applyTransferMapsToBitmap(imgData) {
                  if (this.current.transferMaps === "none") {
                    return imgData.bitmap;
                  }
                  const {
                    bitmap,
                    width,
                    height
                  } = imgData;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                  const tmpCtx = tmpCanvas.context;
                  tmpCtx.filter = this.current.transferMaps;
                  tmpCtx.drawImage(bitmap, 0, 0);
                  tmpCtx.filter = "none";
                  return tmpCanvas.canvas;
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  if (!_is_node2.isNodeJS) {
                    ctx.filter = "none";
                  }
                  ctx.scale(1 / width, -1 / height);
                  let imgToPaint;
                  if (imgData.bitmap) {
                    imgToPaint = this.applyTransferMapsToBitmap(imgData);
                  } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  let imgToPaint;
                  if (imgData.bitmap) {
                    imgToPaint = imgData.bitmap;
                  } else {
                    const w = imgData.width;
                    const h = imgData.height;
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                  }
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag) {
                }
                markPointProps(tag, properties) {
                }
                beginMarkedContent(tag) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag, properties) {
                  if (tag === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m[1] === 0 && m[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[2]);
                      const normY = Math.hypot(m[1], m[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (this._cachedScaleForStroking[0] === -1) {
                    const {
                      lineWidth
                    } = this.current;
                    const {
                      a,
                      b,
                      c,
                      d
                    } = this.ctx.getTransform();
                    let scaleX, scaleY;
                    if (b === 0 && c === 0) {
                      const normX = Math.abs(a);
                      const normY = Math.abs(d);
                      if (normX === normY) {
                        if (lineWidth === 0) {
                          scaleX = scaleY = 1 / normX;
                        } else {
                          const scaledLineWidth = normX * lineWidth;
                          scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                        }
                      } else if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(a * d - b * c);
                      const normX = Math.hypot(a, b);
                      const normY = Math.hypot(c, d);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking[0] = scaleX;
                    this._cachedScaleForStroking[1] = scaleY;
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  const dashes = ctx.getLineDash();
                  if (saveRestore) {
                    ctx.save();
                  }
                  ctx.scale(scaleX, scaleY);
                  if (dashes.length > 0) {
                    const scale = Math.max(scaleX, scaleY);
                    ctx.setLineDash(dashes.map((x) => x / scale));
                    ctx.lineDashOffset /= scale;
                  }
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.restore();
                  }
                }
                isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              let CanvasGraphics = _CanvasGraphics;
              _restoreInitialState = new WeakSet();
              restoreInitialState_fn = function() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              };
              _drawFilter = new WeakSet();
              drawFilter_fn = function() {
                if (this.pageColors) {
                  const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
                  if (hcmFilterId !== "none") {
                    const savedFilter = this.ctx.filter;
                    this.ctx.filter = hcmFilterId;
                    this.ctx.drawImage(this.ctx.canvas, 0, 0);
                    this.ctx.filter = savedFilter;
                  }
                }
              };
              exports2.CanvasGraphics = CanvasGraphics;
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox) {
                  return;
                }
                const width = bbox[2] - bbox[0];
                const height = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width, height);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse);
                    pattern.setTransform(domMatrix);
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width;
                  const scaleY = boundsHeight / height;
                  const context = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width + BORDER_SIZE * 2;
                  const paddedHeight = height + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale;
                  if (pathType === PathType.SHADING) {
                    scale = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              const _TilingPattern = class {
                constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse, pathType) {
                  let matrix = inverse;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  pattern.setTransform(domMatrix);
                  return pattern;
                }
              };
              let TilingPattern = _TilingPattern;
              __publicField(TilingPattern, "MAX_PATTERN_SIZE", 3e3);
              exports2.TilingPattern = TilingPattern;
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
              exports2.convertToRGBA = convertToRGBA;
              exports2.grayToRGBA = grayToRGBA;
              var _util2 = __w_pdfjs_require__2(1);
              function convertToRGBA(params) {
                switch (params.kind) {
                  case _util2.ImageKind.GRAYSCALE_1BPP:
                    return convertBlackAndWhiteToRGBA(params);
                  case _util2.ImageKind.RGB_24BPP:
                    return convertRGBToRGBA(params);
                }
                return null;
              }
              function convertBlackAndWhiteToRGBA({
                src,
                srcPos = 0,
                dest,
                width,
                height,
                nonBlackColor = 4294967295,
                inverseDecode = false
              }) {
                const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                let destPos = 0;
                for (let i = 0; i < height; i++) {
                  for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function convertRGBToRGBA({
                src,
                srcPos = 0,
                dest,
                destPos = 0,
                width,
                height
              }) {
                let i = 0;
                const len32 = src.length >> 2;
                const src32 = new Uint32Array(src.buffer, srcPos, len32);
                if (_util2.FeatureTest.isLittleEndian) {
                  for (; i < len32 - 2; i += 3, destPos += 4) {
                    const s1 = src32[i];
                    const s2 = src32[i + 1];
                    const s3 = src32[i + 2];
                    dest[destPos] = s1 | 4278190080;
                    dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 4278190080;
                    dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 4278190080;
                    dest[destPos + 3] = s3 >>> 8 | 4278190080;
                  }
                  for (let j = i * 4, jj = src.length; j < jj; j += 3) {
                    dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 4278190080;
                  }
                } else {
                  for (; i < len32 - 2; i += 3, destPos += 4) {
                    const s1 = src32[i];
                    const s2 = src32[i + 1];
                    const s3 = src32[i + 2];
                    dest[destPos] = s1 | 255;
                    dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 255;
                    dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 255;
                    dest[destPos + 3] = s3 << 8 | 255;
                  }
                  for (let j = i * 4, jj = src.length; j < jj; j += 3) {
                    dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 255;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              function grayToRGBA(src, dest) {
                if (_util2.FeatureTest.isLittleEndian) {
                  for (let i = 0, ii = src.length; i < ii; i++) {
                    dest[i] = src[i] * 65793 | 4278190080;
                  }
                } else {
                  for (let i = 0, ii = src.length; i < ii; i++) {
                    dest[i] = src[i] * 16843008 | 255;
                  }
                }
              }
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
              GlobalWorkerOptions2.workerPort = null;
              GlobalWorkerOptions2.workerSrc = "";
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  __privateAdd(this, _createStreamSink);
                  __privateAdd(this, _processStreamMessage);
                  __privateAdd(this, _deleteStreamController);
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = new _util2.PromiseCapability();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = new _util2.PromiseCapability();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              _createStreamSink = new WeakSet();
              createStreamSink_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const self2 = this, action = this.actionHandler[data.action];
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = new _util2.PromiseCapability();
                      this.ready = this.sinkCapability.promise;
                    }
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: new _util2.PromiseCapability(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              };
              _processStreamMessage = new WeakSet();
              processStreamMessage_fn = function(data) {
                const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      streamController.startCall.resolve();
                    } else {
                      streamController.startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      streamController.pullCall.resolve();
                    } else {
                      streamController.pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!streamSink) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                      streamSink.sinkCapability.resolve();
                    }
                    streamSink.desiredSize = data.desiredSize;
                    new Promise(function(resolve) {
                      var _a;
                      resolve((_a = streamSink.onPull) == null ? void 0 : _a.call(streamSink));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(streamController, "enqueue should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(streamController, "close should have stream controller");
                    if (streamController.isClosed) {
                      break;
                    }
                    streamController.isClosed = true;
                    streamController.controller.close();
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(streamController, "error should have stream controller");
                    streamController.controller.error(wrapReason(data.reason));
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      streamController.cancelCall.resolve();
                    } else {
                      streamController.cancelCall.reject(wrapReason(data.reason));
                    }
                    __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!streamSink) {
                      break;
                    }
                    new Promise(function(resolve) {
                      var _a;
                      resolve((_a = streamSink.onCancel) == null ? void 0 : _a.call(streamSink, wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    streamSink.sinkCapability.reject(wrapReason(data.reason));
                    streamSink.isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              };
              _deleteStreamController = new WeakSet();
              deleteStreamController_fn = async function(streamController, streamId) {
                var _a, _b, _c;
                await Promise.allSettled([(_a = streamController.startCall) == null ? void 0 : _a.promise, (_b = streamController.pullCall) == null ? void 0 : _b.promise, (_c = streamController.cancelCall) == null ? void 0 : _c.promise]);
                delete this.streamControllers[streamId];
              };
              exports2.MessageHandler = MessageHandler;
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _metadataMap, _data;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class Metadata {
                constructor({
                  parsedData,
                  rawData
                }) {
                  __privateAdd(this, _metadataMap, void 0);
                  __privateAdd(this, _data, void 0);
                  __privateSet(this, _metadataMap, parsedData);
                  __privateSet(this, _data, rawData);
                }
                getRaw() {
                  return __privateGet(this, _data);
                }
                get(name) {
                  return __privateGet(this, _metadataMap).get(name) ?? null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                }
                has(name) {
                  return __privateGet(this, _metadataMap).has(name);
                }
              }
              _metadataMap = new WeakMap();
              _data = new WeakMap();
              exports2.Metadata = Metadata;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _visible, _cachedGetHash, _groups, _initialHash, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _murmurhash = __w_pdfjs_require__2(8);
              const INTERNAL = Symbol("INTERNAL");
              class OptionalContentGroup {
                constructor(name, intent) {
                  __privateAdd(this, _visible, true);
                  this.name = name;
                  this.intent = intent;
                }
                get visible() {
                  return __privateGet(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  __privateSet(this, _visible, visible);
                }
              }
              _visible = new WeakMap();
              class OptionalContentConfig {
                constructor(data) {
                  __privateAdd(this, _evaluateVisibilityExpression);
                  __privateAdd(this, _cachedGetHash, null);
                  __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                  __privateAdd(this, _initialHash, null);
                  __privateAdd(this, _order, null);
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  __privateSet(this, _order, data.order);
                  for (const group of data.groups) {
                    __privateGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group of __privateGet(this, _groups).values()) {
                      group._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on of data.on) {
                    __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  __privateSet(this, _initialHash, this.getHash());
                }
                isVisible(group) {
                  if (__privateGet(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group.type === "OCG") {
                    if (!__privateGet(this, _groups).has(group.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                      return true;
                    }
                    return __privateGet(this, _groups).get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group.type}.`);
                  return true;
                }
                setVisibility(id, visible = true) {
                  if (!__privateGet(this, _groups).has(id)) {
                    (0, _util2.warn)(`Optional content group not found: ${id}`);
                    return;
                  }
                  __privateGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);
                  __privateSet(this, _cachedGetHash, null);
                }
                get hasInitialVisibility() {
                  return this.getHash() === __privateGet(this, _initialHash);
                }
                getOrder() {
                  if (!__privateGet(this, _groups).size) {
                    return null;
                  }
                  if (__privateGet(this, _order)) {
                    return __privateGet(this, _order).slice();
                  }
                  return [...__privateGet(this, _groups).keys()];
                }
                getGroups() {
                  return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
                }
                getGroup(id) {
                  return __privateGet(this, _groups).get(id) || null;
                }
                getHash() {
                  if (__privateGet(this, _cachedGetHash) !== null) {
                    return __privateGet(this, _cachedGetHash);
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [id, group] of __privateGet(this, _groups)) {
                    hash.update(`${id}:${group.visible}`);
                  }
                  return __privateSet(this, _cachedGetHash, hash.hexdigest());
                }
              }
              _cachedGetHash = new WeakMap();
              _groups = new WeakMap();
              _initialHash = new WeakMap();
              _order = new WeakMap();
              _evaluateVisibilityExpression = new WeakSet();
              evaluateVisibilityExpression_fn = function(array) {
                const length = array.length;
                if (length < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i = 1; i < length; i++) {
                  const element = array[i];
                  let state;
                  if (Array.isArray(element)) {
                    state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                  } else if (__privateGet(this, _groups).has(element)) {
                    state = __privateGet(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              };
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              class PDFDataTransportStream {
                constructor({
                  length,
                  initialData,
                  progressiveDone = false,
                  contentDispositionFilename = null,
                  disableRange = false,
                  disableStream = false
                }, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = progressiveDone;
                  this._contentDispositionFilename = contentDispositionFilename;
                  if ((initialData == null ? void 0 : initialData.length) > 0) {
                    const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !disableStream;
                  this._isRangeSupported = !disableRange;
                  this._contentLength = length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData({
                  begin,
                  chunk
                }) {
                  const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
                  if (begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  var _a;
                  return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                }
                _onProgress(evt) {
                  var _a, _b, _c, _d;
                  if (evt.total === void 0) {
                    (_b = (_a = this._rangeReaders[0]) == null ? void 0 : _a.onProgress) == null ? void 0 : _b.call(_a, {
                      loaded: evt.loaded
                    });
                  } else {
                    (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, {
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
                _onProgressiveDone() {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.progressiveDone();
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    var _a;
                    if (!node) {
                      return;
                    }
                    let str = null;
                    const name = node.name;
                    if (name === "#text") {
                      str = node.value;
                    } else if (!XfaText.shouldBuildText(name)) {
                      return;
                    } else if ((_a = node == null ? void 0 : node.attributes) == null ? void 0 : _a.textContent) {
                      str = node.attributes.textContent;
                    } else if (node.value) {
                      str = node.value;
                    }
                    if (str !== null) {
                      items.push({
                        str
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name) {
                  return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeFilterFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(7);
              ;
              const fetchData = function(url) {
                return new Promise((resolve, reject) => {
                  const fs = require_fs();
                  fs.readFile(url, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeFilterFactory extends _base_factory.BaseFilterFactory {
              }
              exports2.NodeFilterFactory = NodeFilterFactory;
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width, height) {
                  const Canvas = require_canvas();
                  return Canvas.createCanvas(width, height);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return fetchData(url).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url) {
                  return fetchData(url);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 21 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(22);
              ;
              const fs = require_fs();
              const http = require_http();
              const https = require_https();
              const url = require_url();
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const parsedUrl = url.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _a;
                  return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = new _util2.PromiseCapability();
                  this._headersCapability = new _util2.PromiseCapability();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a;
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = new _util2.PromiseCapability();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = new _util2.PromiseCapability();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a;
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = new _util2.PromiseCapability();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                    loaded: this._loaded
                  });
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name) => {
                      return this._readableStream.headers[name.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value = stream.httpHeaders[property];
                    if (value === void 0) {
                      continue;
                    }
                    this._httpHeaders[property] = value;
                  }
                  this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  this._setReadableStream(fs.createReadStream(path, {
                    start,
                    end: end - 1
                  }));
                }
              }
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(23);
              var _display_utils2 = __w_pdfjs_require__2(6);
              function validateRangeRequestCapabilities({
                getResponseHeader,
                isHttp,
                rangeChunkSize,
                disableRange
              }) {
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length;
                if (length <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url) {
                if (status === 404 || status === 0 && url.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value)) {
                      return value;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value);
                      value = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch {
                    }
                  }
                  return value;
                }
                function fixupEncoding(value) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                    value = textdecode("utf-8", value);
                    if (needsEncodingFixup) {
                      value = textdecode("iso-8859-1", value);
                    }
                  }
                  return value;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n, quot, part] = match;
                    n = parseInt(n, 10);
                    if (n in matches) {
                      if (n === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n] = [quot, part];
                  }
                  const parts = [];
                  for (let n = 0; n < matches.length; ++n) {
                    if (!(n in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value) {
                  if (value.startsWith('"')) {
                    const parts = value.slice(1).split('\\"');
                    for (let i = 0; i < parts.length; ++i) {
                      const quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
                    }
                    value = parts.join('"');
                  }
                  return value;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value);
                }
                function rfc2047decode(value) {
                  if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                    return value;
                  }
                  return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                    if (encoding === "q" || encoding === "Q") {
                      text = text.replaceAll("_", " ");
                      text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text);
                    }
                    try {
                      text = atob(text);
                    } catch {
                    }
                    return textdecode(charset, text);
                  });
                }
                return "";
              }
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(22);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                return (0, _util2.stringToBytes)(data).buffer;
              }
              class NetworkManager {
                constructor(url, args = {}) {
                  this.url = url;
                  this.isHttp = /^https?:/i.test(url);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end, listeners) {
                  const args = {
                    begin,
                    end
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = new XMLHttpRequest();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value = this.httpHeaders[property];
                    if (value === void 0) {
                      continue;
                    }
                    xhr.setRequestHeader(property, value);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  var _a;
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  (_a = pendingRequest.onProgress) == null ? void 0 : _a.call(pendingRequest, evt);
                }
                onStateChange(xhrId, evt) {
                  var _a, _b, _c;
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    (_a = pendingRequest.onError) == null ? void 0 : _a.call(pendingRequest, xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    (_b = pendingRequest.onError) == null ? void 0 : _b.call(pendingRequest, xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    (_c = pendingRequest.onError) == null ? void 0 : _c.call(pendingRequest, xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = new _util2.PromiseCapability();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name) => {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  var _a;
                  (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  var _a;
                  (_a = this.onClosed) == null ? void 0 : _a.call(this, this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  var _a;
                  if (!this.isStreamingSupported) {
                    (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = new _util2.PromiseCapability();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(22);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value = httpHeaders[property];
                  if (value === void 0) {
                    continue;
                  }
                  headers.append(property, value);
                }
                return headers;
              }
              function getArrayBuffer(val) {
                if (val instanceof Uint8Array) {
                  return val.buffer;
                }
                if (val instanceof ArrayBuffer) {
                  return val;
                }
                (0, _util2.warn)(`getArrayBuffer - unexpected data format: ${val}`);
                return new Uint8Array(val).buffer;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  var _a;
                  return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  var _a;
                  (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = new _util2.PromiseCapability();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name) => {
                      return response.headers.get(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a;
                  await this._headersCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                  return {
                    value: getArrayBuffer(value),
                    done: false
                  };
                }
                cancel(reason) {
                  var _a;
                  (_a = this._reader) == null ? void 0 : _a.cancel(reason);
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = new _util2.PromiseCapability();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                  const url = source.url;
                  fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  var _a;
                  await this._readCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                    loaded: this._loaded
                  });
                  return {
                    value: getArrayBuffer(value),
                    done: false
                  };
                }
                cancel(reason) {
                  var _a;
                  (_a = this._reader) == null ? void 0 : _a.cancel(reason);
                  this._abortController.abort();
                }
              }
            },
            /* 26 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              exports2.updateTextLayer = updateTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              function getCtx(size, isOffscreenCanvasSupported) {
                let ctx;
                if (isOffscreenCanvasSupported && _util2.FeatureTest.isOffscreenCanvasSupported) {
                  ctx = new OffscreenCanvas(size, size).getContext("2d", {
                    alpha: false
                  });
                } else {
                  const canvas = document.createElement("canvas");
                  canvas.width = canvas.height = size;
                  ctx = canvas.getContext("2d", {
                    alpha: false
                  });
                }
                return ctx;
              }
              function getAscent(fontFamily, isOffscreenCanvasSupported) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  ctx.canvas.width = ctx.canvas.height = 0;
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.canvas.width = ctx.canvas.height = 0;
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles) {
                const textDiv = document.createElement("span");
                const textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._transform, geom.transform);
                let angle = Math.atan2(tx[1], tx[0]);
                const style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                const scaleFactorStr = "calc(var(--scale-factor)*";
                const divStyle = textDiv.style;
                if (task._container === task._rootContainer) {
                  divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;
                  divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;
                } else {
                  divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
                  divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
                }
                divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;
                divStyle.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._isReadableStream) {
                  task._layoutText(textDiv);
                }
              }
              function layout(params) {
                const {
                  div,
                  scale,
                  properties,
                  ctx,
                  prevFontSize,
                  prevFontFamily
                } = params;
                const {
                  style
                } = div;
                let transform = "";
                if (properties.canvasWidth !== 0 && properties.hasText) {
                  const {
                    fontFamily
                  } = style;
                  const {
                    canvasWidth,
                    fontSize
                  } = properties;
                  if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
                    ctx.font = `${fontSize * scale}px ${fontFamily}`;
                    params.prevFontSize = fontSize;
                    params.prevFontFamily = fontFamily;
                  }
                  const {
                    width
                  } = ctx.measureText(div.textContent);
                  if (width > 0) {
                    transform = `scaleX(${canvasWidth * scale / width})`;
                  }
                }
                if (properties.angle !== 0) {
                  transform = `rotate(${properties.angle}deg) ${transform}`;
                }
                if (transform.length > 0) {
                  style.transform = transform;
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  capability.resolve();
                  return;
                }
                if (!task._isReadableStream) {
                  for (const textDiv of textDivs) {
                    task._layoutText(textDiv);
                  }
                }
                capability.resolve();
              }
              class TextLayerRenderTask {
                constructor({
                  textContentSource,
                  container,
                  viewport,
                  textDivs,
                  textDivProperties,
                  textContentItemsStr,
                  isOffscreenCanvasSupported
                }) {
                  var _a;
                  this._textContentSource = textContentSource;
                  this._isReadableStream = textContentSource instanceof ReadableStream;
                  this._container = this._rootContainer = container;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;
                  this._fontInspectorEnabled = !!((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled);
                  this._reader = null;
                  this._textDivProperties = textDivProperties || /* @__PURE__ */ new WeakMap();
                  this._canceled = false;
                  this._capability = new _util2.PromiseCapability();
                  this._layoutTextParams = {
                    prevFontSize: null,
                    prevFontFamily: null,
                    div: null,
                    scale: viewport.scale * (globalThis.devicePixelRatio || 1),
                    properties: null,
                    ctx: getCtx(0, isOffscreenCanvasSupported)
                  };
                  const {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  } = viewport.rawDims;
                  this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
                  this._pageWidth = pageWidth;
                  this._pageHeight = pageHeight;
                  (0, _display_utils2.setLayerDimensions)(container, viewport);
                  this._capability.promise.finally(() => {
                    this._layoutTextParams = null;
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  this._capability.reject(new _util2.AbortException("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (const item of items) {
                    if (item.str === void 0) {
                      if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (item.id !== null) {
                          this._container.setAttribute("id", `${item.id}`);
                        }
                        parent.append(this._container);
                      } else if (item.type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(item.str);
                    appendText(this, item, styleCache);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);
                  this._layoutTextParams.div = textDiv;
                  layout(this._layoutTextParams);
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br = document.createElement("br");
                    br.setAttribute("role", "presentation");
                    this._container.append(br);
                  }
                }
                _render() {
                  const capability = new _util2.PromiseCapability();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  if (this._isReadableStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentSource.getReader();
                    pump();
                  } else if (this._textContentSource) {
                    const {
                      items,
                      styles
                    } = this._textContentSource;
                    this._processItems(items, styles);
                    capability.resolve();
                  } else {
                    throw new Error('No "textContentSource" parameter specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    render(this);
                  }, this._capability.reject);
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(params) {
                if (!params.textContentSource && (params.textContent || params.textContentStream)) {
                  (0, _display_utils2.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.");
                  params.textContentSource = params.textContent || params.textContentStream;
                }
                const {
                  container,
                  viewport
                } = params;
                const style = getComputedStyle(container);
                const visibility = style.getPropertyValue("visibility");
                const scaleFactor = parseFloat(style.getPropertyValue("--scale-factor"));
                if (visibility === "visible" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {
                  console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
                }
                const task = new TextLayerRenderTask(params);
                task._render();
                return task;
              }
              function updateTextLayer({
                container,
                viewport,
                textDivs,
                textDivProperties,
                isOffscreenCanvasSupported,
                mustRotate = true,
                mustRescale = true
              }) {
                if (mustRotate) {
                  (0, _display_utils2.setLayerDimensions)(container, {
                    rotation: viewport.rotation
                  });
                }
                if (mustRescale) {
                  const ctx = getCtx(0, isOffscreenCanvasSupported);
                  const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
                  const params = {
                    prevFontSize: null,
                    prevFontFamily: null,
                    div: null,
                    scale,
                    properties: null,
                    ctx
                  };
                  for (const div of textDivs) {
                    params.properties = textDivProperties.get(div);
                    params.div = div;
                    layout(params);
                  }
                }
              }
            },
            /* 27 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _accessibilityManager, _allowClick, _annotationLayer, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _isDisabling, _uiManager, _changeParent, changeParent_fn, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _cleanup, cleanup_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _tools = __w_pdfjs_require__2(5);
              var _freetext = __w_pdfjs_require__2(28);
              var _ink = __w_pdfjs_require__2(33);
              var _display_utils2 = __w_pdfjs_require__2(6);
              const _AnnotationEditorLayer = class {
                constructor(options) {
                  __privateAdd(this, _changeParent);
                  __privateAdd(this, _createNewEditor);
                  __privateAdd(this, _createAndAddNewEditor);
                  __privateAdd(this, _cleanup);
                  __privateAdd(this, _accessibilityManager, void 0);
                  __privateAdd(this, _allowClick, false);
                  __privateAdd(this, _annotationLayer, null);
                  __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                  __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                  __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _hadPointerDown, false);
                  __privateAdd(this, _isCleaningUp, false);
                  __privateAdd(this, _isDisabling, false);
                  __privateAdd(this, _uiManager, void 0);
                  if (!_AnnotationEditorLayer._initialized) {
                    _AnnotationEditorLayer._initialized = true;
                    _freetext.FreeTextEditor.initialize(options.l10n);
                    _ink.InkEditor.initialize(options.l10n);
                  }
                  options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
                  __privateSet(this, _uiManager, options.uiManager);
                  this.pageIndex = options.pageIndex;
                  this.div = options.div;
                  __privateSet(this, _accessibilityManager, options.accessibilityManager);
                  __privateSet(this, _annotationLayer, options.annotationLayer);
                  this.viewport = options.viewport;
                  __privateGet(this, _uiManager).addLayer(this);
                }
                get isEmpty() {
                  return __privateGet(this, _editors).size === 0;
                }
                updateToolbar(mode) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                }
                updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  __privateGet(this, _uiManager).unselectAll();
                  if (mode !== _util2.AnnotationEditorType.NONE) {
                    this.div.classList.toggle("freeTextEditing", mode === _util2.AnnotationEditorType.FREETEXT);
                    this.div.classList.toggle("inkEditing", mode === _util2.AnnotationEditorType.INK);
                    this.div.hidden = false;
                  }
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor2 of __privateGet(this, _editors).values()) {
                      if (editor2.isEmpty()) {
                        editor2.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  });
                  editor.setInBackground();
                }
                setEditingState(isEditing) {
                  __privateGet(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  __privateGet(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  const annotationElementIds = /* @__PURE__ */ new Set();
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.enableEditing();
                    if (editor.annotationElementId) {
                      annotationElementIds.add(editor.annotationElementId);
                    }
                  }
                  if (!__privateGet(this, _annotationLayer)) {
                    return;
                  }
                  const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                  for (const editable of editables) {
                    editable.hide();
                    if (__privateGet(this, _uiManager).isDeletedAnnotationElement(editable.data.id)) {
                      continue;
                    }
                    if (annotationElementIds.has(editable.data.id)) {
                      continue;
                    }
                    const editor = this.deserialize(editable);
                    if (!editor) {
                      continue;
                    }
                    this.addOrRebuild(editor);
                    editor.enableEditing();
                  }
                }
                disable() {
                  var _a;
                  __privateSet(this, _isDisabling, true);
                  this.div.style.pointerEvents = "none";
                  const hiddenAnnotationIds = /* @__PURE__ */ new Set();
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.disableEditing();
                    if (!editor.annotationElementId || editor.serialize() !== null) {
                      hiddenAnnotationIds.add(editor.annotationElementId);
                      continue;
                    }
                    (_a = this.getEditableAnnotation(editor.annotationElementId)) == null ? void 0 : _a.show();
                    editor.remove();
                  }
                  if (__privateGet(this, _annotationLayer)) {
                    const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                    for (const editable of editables) {
                      const {
                        id
                      } = editable.data;
                      if (hiddenAnnotationIds.has(id) || __privateGet(this, _uiManager).isDeletedAnnotationElement(id)) {
                        continue;
                      }
                      editable.show();
                    }
                  }
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (this.isEmpty) {
                    this.div.hidden = true;
                  }
                  __privateSet(this, _isDisabling, false);
                }
                getEditableAnnotation(id) {
                  var _a;
                  return ((_a = __privateGet(this, _annotationLayer)) == null ? void 0 : _a.getEditableAnnotation(id)) || null;
                }
                setActiveEditor(editor) {
                  const currentActive = __privateGet(this, _uiManager).getActive();
                  if (currentActive === editor) {
                    return;
                  }
                  __privateGet(this, _uiManager).setActiveEditor(editor);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                attach(editor) {
                  __privateGet(this, _editors).set(editor.id, editor);
                  const {
                    annotationElementId
                  } = editor;
                  if (annotationElementId && __privateGet(this, _uiManager).isDeletedAnnotationElement(annotationElementId)) {
                    __privateGet(this, _uiManager).removeDeletedAnnotationElement(editor);
                  }
                }
                detach(editor) {
                  var _a;
                  __privateGet(this, _editors).delete(editor.id);
                  (_a = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a.removePointerInTextLayer(editor.contentDiv);
                  if (!__privateGet(this, _isDisabling) && editor.annotationElementId) {
                    __privateGet(this, _uiManager).addDeletedAnnotationElement(editor);
                  }
                }
                remove(editor) {
                  this.detach(editor);
                  __privateGet(this, _uiManager).removeEditor(editor);
                  editor.div.style.display = "none";
                  setTimeout(() => {
                    editor.div.style.display = "";
                    editor.div.remove();
                    editor.isAttachedToDOM = false;
                    if (document.activeElement === document.body) {
                      __privateGet(this, _uiManager).focusMainContainer();
                    }
                  }, 0);
                  if (!__privateGet(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                add(editor) {
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  __privateGet(this, _uiManager).addEditor(editor);
                  this.attach(editor);
                  if (!editor.isAttachedToDOM) {
                    const div = editor.render();
                    this.div.append(div);
                    editor.isAttachedToDOM = true;
                  }
                  this.moveEditorInDOM(editor);
                  editor.onceAdded();
                  __privateGet(this, _uiManager).addToAnnotationStorage(editor);
                }
                moveEditorInDOM(editor) {
                  var _a;
                  (_a = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
                }
                addOrRebuild(editor) {
                  if (editor.needsToBeRebuilt()) {
                    editor.rebuild();
                  } else {
                    this.add(editor);
                  }
                }
                getNextId() {
                  return __privateGet(this, _uiManager).getId();
                }
                deserialize(data) {
                  switch (data.annotationType ?? data.annotationEditorType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this, __privateGet(this, _uiManager));
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this, __privateGet(this, _uiManager));
                  }
                  return null;
                }
                setSelected(editor) {
                  __privateGet(this, _uiManager).setSelected(editor);
                }
                toggleSelected(editor) {
                  __privateGet(this, _uiManager).toggleSelected(editor);
                }
                isSelected(editor) {
                  return __privateGet(this, _uiManager).isSelected(editor);
                }
                unselect(editor) {
                  __privateGet(this, _uiManager).unselect(editor);
                }
                pointerup(event) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!__privateGet(this, _hadPointerDown)) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, false);
                  if (!__privateGet(this, _allowClick)) {
                    __privateSet(this, _allowClick, true);
                    return;
                  }
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event);
                }
                pointerdown(event) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, true);
                  const editor = __privateGet(this, _uiManager).getActive();
                  __privateSet(this, _allowClick, !editor || editor.isEmpty());
                }
                drop(event) {
                  const id = event.dataTransfer.getData("text/plain");
                  const editor = __privateGet(this, _uiManager).getEditor(id);
                  if (!editor) {
                    return;
                  }
                  event.preventDefault();
                  event.dataTransfer.dropEffect = "move";
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  const rect = this.div.getBoundingClientRect();
                  const endX = event.clientX - rect.x;
                  const endY = event.clientY - rect.y;
                  editor.translate(endX - editor.startX, endY - editor.startY);
                  this.moveEditorInDOM(editor);
                  editor.div.focus();
                }
                dragover(event) {
                  event.preventDefault();
                }
                destroy() {
                  var _a, _b;
                  if (((_a = __privateGet(this, _uiManager).getActive()) == null ? void 0 : _a.parent) === this) {
                    __privateGet(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor of __privateGet(this, _editors).values()) {
                    (_b = __privateGet(this, _accessibilityManager)) == null ? void 0 : _b.removePointerInTextLayer(editor.contentDiv);
                    editor.setParent(null);
                    editor.isAttachedToDOM = false;
                    editor.div.remove();
                  }
                  this.div = null;
                  __privateGet(this, _editors).clear();
                  __privateGet(this, _uiManager).removeLayer(this);
                }
                render({
                  viewport
                }) {
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(this.div, viewport);
                  (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
                  for (const editor of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor);
                  }
                  this.updateMode();
                }
                update({
                  viewport
                }) {
                  __privateGet(this, _uiManager).commitOrRemove();
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(this.div, {
                    rotation: viewport.rotation
                  });
                  this.updateMode();
                }
                get pageDimensions() {
                  const {
                    pageWidth,
                    pageHeight
                  } = this.viewport.rawDims;
                  return [pageWidth, pageHeight];
                }
              };
              let AnnotationEditorLayer = _AnnotationEditorLayer;
              _accessibilityManager = new WeakMap();
              _allowClick = new WeakMap();
              _annotationLayer = new WeakMap();
              _boundPointerup = new WeakMap();
              _boundPointerdown = new WeakMap();
              _editors = new WeakMap();
              _hadPointerDown = new WeakMap();
              _isCleaningUp = new WeakMap();
              _isDisabling = new WeakMap();
              _uiManager = new WeakMap();
              _changeParent = new WeakSet();
              changeParent_fn = function(editor) {
                var _a;
                if (editor.parent === this) {
                  return;
                }
                if (editor.annotationElementId) {
                  __privateGet(this, _uiManager).addDeletedAnnotationElement(editor.annotationElementId);
                  _editor.AnnotationEditor.deleteAnnotationElement(editor);
                  editor.annotationElementId = null;
                }
                this.attach(editor);
                (_a = editor.parent) == null ? void 0 : _a.detach(editor);
                editor.setParent(this);
                if (editor.div && editor.isAttachedToDOM) {
                  editor.div.remove();
                  this.div.append(editor.div);
                }
              };
              _createNewEditor = new WeakSet();
              createNewEditor_fn = function(params) {
                switch (__privateGet(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                }
                return null;
              };
              _createAndAddNewEditor = new WeakSet();
              createAndAddNewEditor_fn = function(event) {
                const id = this.getNextId();
                const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id,
                  x: event.offsetX,
                  y: event.offsetY,
                  uiManager: __privateGet(this, _uiManager)
                });
                if (editor) {
                  this.add(editor);
                }
                return editor;
              };
              _cleanup = new WeakSet();
              cleanup_fn = function() {
                __privateSet(this, _isCleaningUp, true);
                for (const editor of __privateGet(this, _editors).values()) {
                  if (editor.isEmpty()) {
                    editor.remove();
                  }
                }
                __privateSet(this, _isCleaningUp, false);
              };
              __publicField(AnnotationEditorLayer, "_initialized", false);
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
            },
            /* 28 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivInput, _boundEditorDivKeydown, _color, _content, _editorDivId, _fontSize, _initialData, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn, _setContent, setContent_fn, _hasElementChanged, hasElementChanged_fn, _cheatInitialRect, cheatInitialRect_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(5);
              var _editor = __w_pdfjs_require__2(4);
              var _annotation_layer = __w_pdfjs_require__2(29);
              const _FreeTextEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  __privateAdd(this, _updateFontSize);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _setEditorDimensions);
                  __privateAdd(this, _setContent);
                  __privateAdd(this, _hasElementChanged);
                  __privateAdd(this, _cheatInitialRect);
                  __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                  __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                  __privateAdd(this, _boundEditorDivInput, this.editorDivInput.bind(this));
                  __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                  __privateAdd(this, _color, void 0);
                  __privateAdd(this, _content, "");
                  __privateAdd(this, _editorDivId, `${this.id}-editor`);
                  __privateAdd(this, _fontSize, void 0);
                  __privateAdd(this, _initialData, null);
                  __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
                }
                static get _keyboardManager() {
                  return (0, _util2.shadow)(this, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], _FreeTextEditor.prototype.commitOrRemove, true], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], _FreeTextEditor.prototype.commitOrRemove]]));
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["free_text2_default_content", "editor_free_text2_aria_label"].map((str) => [str, l10n.get(str)]));
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _FreeTextEditor._defaultFontSize = value;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _FreeTextEditor._defaultColor = value;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
                }
                getInitialTranslation() {
                  const scale = this.parentScale;
                  return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * scale];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this.div.draggable = false;
                  this.div.removeAttribute("aria-activedescendant");
                  this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.editorDiv.addEventListener("input", __privateGet(this, _boundEditorDivInput));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.setAttribute("aria-activedescendant", __privateGet(this, _editorDivId));
                  this.div.draggable = true;
                  this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.editorDiv.removeEventListener("input", __privateGet(this, _boundEditorDivInput));
                  this.div.focus({
                    preventScroll: true
                  });
                  this.isEditing = false;
                  this.parent.div.classList.add("freeTextEditing");
                }
                focusin(event) {
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  if (this.width) {
                    __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this);
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  this.parent.setEditingState(true);
                  this.parent.div.classList.add("freeTextEditing");
                  super.remove();
                }
                commit() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  super.commit();
                  this.disableEditMode();
                  const savedText = __privateGet(this, _content);
                  const newText = __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                  if (savedText === newText) {
                    return;
                  }
                  const setText = (text) => {
                    __privateSet(this, _content, text);
                    if (!text) {
                      this.remove();
                      return;
                    }
                    __privateMethod(this, _setContent, setContent_fn).call(this);
                    this.rebuild();
                    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                  };
                  this.addCommands({
                    cmd: () => {
                      setText(newText);
                    },
                    undo: () => {
                      setText(savedText);
                    },
                    mustExec: false
                  });
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                dblclick(event) {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enableEditMode();
                    this.editorDiv.focus();
                  }
                }
                editorDivKeydown(event) {
                  _FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                editorDivInput(event) {
                  this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", __privateGet(this, _editorDivId));
                  this.enableEditing();
                  _FreeTextEditor._l10nPromise.get("editor_free_text2_aria_label").then((msg) => {
                    var _a;
                    return (_a = this.editorDiv) == null ? void 0 : _a.setAttribute("aria-label", msg);
                  });
                  _FreeTextEditor._l10nPromise.get("free_text2_default_content").then((msg) => {
                    var _a;
                    return (_a = this.editorDiv) == null ? void 0 : _a.setAttribute("default-content", msg);
                  });
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = __privateGet(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    if (this.annotationElementId) {
                      const [tx] = this.getInitialTranslation();
                      this.setAt(baseX * parentWidth, baseY * parentHeight, tx, tx);
                    } else {
                      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    }
                    __privateMethod(this, _setContent, setContent_fn).call(this);
                    this.div.draggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this.div.draggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent, uiManager) {
                  let initialData = null;
                  if (data instanceof _annotation_layer.FreeTextAnnotationElement) {
                    const {
                      data: {
                        defaultAppearanceData: {
                          fontSize,
                          fontColor
                        },
                        rect,
                        rotation,
                        id
                      },
                      textContent,
                      parent: {
                        page: {
                          pageNumber
                        }
                      }
                    } = data;
                    if (!textContent || textContent.length === 0) {
                      return null;
                    }
                    initialData = data = {
                      annotationType: _util2.AnnotationEditorType.FREETEXT,
                      color: Array.from(fontColor),
                      fontSize,
                      value: textContent.join("\n"),
                      pageIndex: pageNumber - 1,
                      rect,
                      rotation,
                      id,
                      deleted: false
                    };
                  }
                  const editor = super.deserialize(data, parent, uiManager);
                  __privateSet(editor, _fontSize, data.fontSize);
                  __privateSet(editor, _color, _util2.Util.makeHexColor(...data.color));
                  __privateSet(editor, _content, data.value);
                  editor.annotationElementId = data.id || null;
                  __privateSet(editor, _initialData, initialData);
                  return editor;
                }
                serialize(isForCopying = false) {
                  if (this.isEmpty()) {
                    return null;
                  }
                  if (this.deleted) {
                    return {
                      pageIndex: this.pageIndex,
                      id: this.annotationElementId,
                      deleted: true
                    };
                  }
                  const padding = _FreeTextEditor._internalPadding * this.parentScale;
                  const rect = this.getRect(padding, padding);
                  const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _color));
                  const serialized = {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color,
                    fontSize: __privateGet(this, _fontSize),
                    value: __privateGet(this, _content),
                    pageIndex: this.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                  if (isForCopying) {
                    return serialized;
                  }
                  if (this.annotationElementId && !__privateMethod(this, _hasElementChanged, hasElementChanged_fn).call(this, serialized)) {
                    return null;
                  }
                  serialized.id = this.annotationElementId;
                  return serialized;
                }
              };
              let FreeTextEditor = _FreeTextEditor;
              _boundEditorDivBlur = new WeakMap();
              _boundEditorDivFocus = new WeakMap();
              _boundEditorDivInput = new WeakMap();
              _boundEditorDivKeydown = new WeakMap();
              _color = new WeakMap();
              _content = new WeakMap();
              _editorDivId = new WeakMap();
              _fontSize = new WeakMap();
              _initialData = new WeakMap();
              _updateFontSize = new WeakSet();
              updateFontSize_fn = function(fontSize) {
                const setFontsize = (size) => {
                  this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
                  this.translate(0, -(size - __privateGet(this, _fontSize)) * this.parentScale);
                  __privateSet(this, _fontSize, size);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                };
                const savedFontsize = __privateGet(this, _fontSize);
                this.addCommands({
                  cmd: () => {
                    setFontsize(fontSize);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = __privateGet(this, _color);
                this.addCommands({
                  cmd: () => {
                    __privateSet(this, _color, this.editorDiv.style.color = color);
                  },
                  undo: () => {
                    __privateSet(this, _color, this.editorDiv.style.color = savedColor);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (const div of divs) {
                  buffer.push(div.innerText.replace(/\r\n?|\n/, ""));
                }
                return buffer.join("\n");
              };
              _setEditorDimensions = new WeakSet();
              setEditorDimensions_fn = function() {
                const [parentWidth, parentHeight] = this.parentDimensions;
                let rect;
                if (this.isAttachedToDOM) {
                  rect = this.div.getBoundingClientRect();
                } else {
                  const {
                    currentLayer,
                    div
                  } = this;
                  const savedDisplay = div.style.display;
                  div.style.display = "hidden";
                  currentLayer.div.append(this.div);
                  rect = div.getBoundingClientRect();
                  div.remove();
                  div.style.display = savedDisplay;
                }
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              };
              _setContent = new WeakSet();
              setContent_fn = function() {
                this.editorDiv.replaceChildren();
                if (!__privateGet(this, _content)) {
                  return;
                }
                for (const line of __privateGet(this, _content).split("\n")) {
                  const div = document.createElement("div");
                  div.append(line ? document.createTextNode(line) : document.createElement("br"));
                  this.editorDiv.append(div);
                }
              };
              _hasElementChanged = new WeakSet();
              hasElementChanged_fn = function(serialized) {
                const {
                  value,
                  fontSize,
                  color,
                  rect,
                  pageIndex
                } = __privateGet(this, _initialData);
                return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i) => Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
              };
              _cheatInitialRect = new WeakSet();
              cheatInitialRect_fn = function(delayed = false) {
                if (!this.annotationElementId) {
                  return;
                }
                __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                if (!delayed && (this.width === 0 || this.height === 0)) {
                  setTimeout(() => __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this, true), 0);
                  return;
                }
                const padding = _FreeTextEditor._internalPadding * this.parentScale;
                __privateGet(this, _initialData).rect = this.getRect(padding, padding);
              };
              __publicField(FreeTextEditor, "_freeTextDefaultContent", "");
              __publicField(FreeTextEditor, "_l10nPromise");
              __publicField(FreeTextEditor, "_internalPadding", 0);
              __publicField(FreeTextEditor, "_defaultColor", null);
              __publicField(FreeTextEditor, "_defaultFontSize", 10);
              __publicField(FreeTextEditor, "_type", "freetext");
              exports2.FreeTextEditor = FreeTextEditor;
            },
            /* 29 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _setInternalLink, setInternalLink_fn, _bindSetOCGState, bindSetOCGState_fn, _dateTimePromise, _boundHide, _boundShow, _boundToggle, _color, _container, _contentsObj, _elements, _parent, _parentRect, _pinned, _popup, _rect, _richText, _titleObj, _wasVisible, _toggle, toggle_fn, _show, show_fn, _hide, hide_fn, _line, _square, _circle, _polyline, _polylines, _trigger, _accessibilityManager, _annotationCanvasMap, _editableAnnotations, _appendElement, appendElement_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkAnnotationElement = exports2.FreeTextAnnotationElement = exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _annotation_storage2 = __w_pdfjs_require__2(3);
              var _scripting_utils = __w_pdfjs_require__2(30);
              var _xfa_layer = __w_pdfjs_require__2(31);
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                        case "Sig":
                          return new SignatureWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              class AnnotationElement {
                constructor(parameters, {
                  isRenderable = false,
                  ignoreBorder = false,
                  createQuadrilaterals = false
                } = {}) {
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this.parent = parameters.parent;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createContainer(ignoreBorder) {
                  const {
                    data,
                    parent: {
                      page,
                      viewport
                    }
                  } = this;
                  const container = document.createElement("section");
                  container.setAttribute("data-annotation-id", data.id);
                  container.style.zIndex = this.parent.zIndex++;
                  if (this.data.popupRef) {
                    container.setAttribute("aria-haspopup", "dialog");
                  }
                  if (data.noRotate) {
                    container.classList.add("norotate");
                  }
                  const {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  } = viewport.rawDims;
                  if (!data.rect || this instanceof PopupAnnotationElement) {
                    const {
                      rotation: rotation2
                    } = data;
                    if (!data.hasOwnCanvas && rotation2 !== 0) {
                      this.setRotation(rotation2, container);
                    }
                    return container;
                  }
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width / pageWidth}%`;
                    container.style.height = `${100 * height / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle, container = this.container) {
                  const {
                    pageWidth,
                    pageHeight
                  } = this.parent.viewport.rawDims;
                  const {
                    width,
                    height
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle % 180 === 0) {
                    elementWidth = 100 * width / pageWidth;
                    elementHeight = 100 * height / pageHeight;
                  } else {
                    elementWidth = 100 * height / pageWidth;
                    elementHeight = 100 * width / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color = event.detail[jsName];
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const hidden = event.detail.display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden,
                        print: event.detail.display === 0 || event.detail.display === 3
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        print: event.detail.print
                      });
                    },
                    hidden: (event) => {
                      this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden: event.detail.hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      if (event.detail.readonly) {
                        event.target.setAttribute("readonly", "");
                      } else {
                        event.target.removeAttribute("readonly");
                      }
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle = event.detail.rotation;
                      this.setRotation(angle);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name of Object.keys(jsEvent.detail)) {
                    const action = actions[name] || commonActions[name];
                    action == null ? void 0 : action(jsEvent);
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals(ignoreBorder = false) {
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  const quadrilaterals = [];
                  const savedRect = this.data.rect;
                  let firstQuadRect = null;
                  for (const quadPoint of this.data.quadPoints) {
                    this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                    quadrilaterals.push(this._createContainer(ignoreBorder));
                    firstQuadRect || (firstQuadRect = this.data.rect);
                  }
                  this.data.rect = savedRect;
                  this.firstQuadRect = firstQuadRect;
                  return quadrilaterals;
                }
                _createPopup() {
                  const {
                    container,
                    data
                  } = this;
                  container.setAttribute("aria-haspopup", "dialog");
                  const popup = new PopupAnnotationElement({
                    data: {
                      color: data.color,
                      titleObj: data.titleObj,
                      modificationDate: data.modificationDate,
                      contentsObj: data.contentsObj,
                      richText: data.richText,
                      parentRect: this.firstQuadRect || data.rect,
                      borderStyle: 0,
                      id: `popup_${data.id}`,
                      rotation: data.rotation
                    },
                    parent: this.parent,
                    elements: [this]
                  });
                  this.parent.div.append(popup.render());
                }
                _renderQuadrilaterals(className) {
                  for (const quadrilateral of this.quadrilaterals) {
                    quadrilateral.classList.add(className);
                  }
                  return this.quadrilaterals;
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name, skipId = null) {
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name];
                    if (fieldObj) {
                      for (const {
                        page,
                        id,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id}`);
                          continue;
                        }
                        fields.push({
                          id,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name)) {
                    const {
                      exportValue
                    } = domElement;
                    const id = domElement.getAttribute("data-element-id");
                    if (id === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                show() {
                  var _a;
                  if (this.container) {
                    this.container.hidden = false;
                  }
                  (_a = this.popup) == null ? void 0 : _a.maybeShow();
                }
                hide() {
                  var _a;
                  if (this.container) {
                    this.container.hidden = true;
                  }
                  (_a = this.popup) == null ? void 0 : _a.forceHide();
                }
                getElementsToTriggerPopup() {
                  return this.quadrilaterals || this.container;
                }
                addHighlightArea() {
                  const triggers = this.getElementsToTriggerPopup();
                  if (Array.isArray(triggers)) {
                    for (const element of triggers) {
                      element.classList.add("highlightArea");
                    }
                  } else {
                    triggers.classList.add("highlightArea");
                  }
                }
              }
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters, options = null) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
                    createQuadrilaterals: true
                  });
                  __privateAdd(this, _setInternalLink);
                  __privateAdd(this, _bindSetOCGState);
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.attachment) {
                    this._bindAttachment(link, data.attachment);
                    isBound = true;
                  } else if (data.setOCGState) {
                    __privateMethod(this, _bindSetOCGState, bindSetOCGState_fn).call(this, link, data.setOCGState);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                      const linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.append(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.classList.add("linkAnnotation");
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindAttachment(link, attachment) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    var _a;
                    (_a = this.downloadManager) == null ? void 0 : _a.openOrDownloadData(this.container, attachment.content, attachment.filename);
                    return false;
                  };
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name of Object.keys(data.actions)) {
                    const jsName = map.get(name);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      var _a;
                      (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    var _a;
                    otherClickAction == null ? void 0 : otherClickAction();
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id
                        } of fields) {
                          fieldIds.add(id);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id
                      } = field;
                      allIds.push(id);
                      switch (field.type) {
                        case "text": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value = field.defaultValue === field.exportValues;
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              _setInternalLink = new WeakSet();
              setInternalLink_fn = function() {
                this.container.setAttribute("data-internal-link", "");
              };
              _bindSetOCGState = new WeakSet();
              bindSetOCGState_fn = function(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeSetOCGState(action);
                  return false;
                };
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
              };
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  this.container.classList.add("textAnnotation");
                  const image = document.createElement("img");
                  image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image.alt = "[{{type}} Annotation]";
                  image.dataset.l10nId = "text_annotation_type";
                  image.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  this.container.append(image);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                showElementAndHideCanvas(element) {
                  var _a;
                  if (this.data.hasOwnCanvas) {
                    if (((_a = element.previousSibling) == null ? void 0 : _a.nodeName) === "CANVAS") {
                      element.previousSibling.hidden = true;
                    }
                    element.hidden = false;
                  }
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = _util2.FeatureTest.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      var _a;
                      (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      var _a;
                      (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, names, getter) {
                  var _a;
                  for (const [baseName, eventName] of names) {
                    if (eventName === "Action" || ((_a = this.data.actions) == null ? void 0 : _a[eventName])) {
                      this._setEventListener(element, baseName, eventName, getter);
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color = this.data.backgroundColor || null;
                  element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  const BORDER_SIZE = 2;
                  const roundToOneDecimal = (x) => Math.round(10 * x) / 10;
                  if (this.data.multiLine) {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                    const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                    const lineHeight = height / numberOfLines;
                    computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                    computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired) {
                  if (isRequired) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value
                    });
                  }
                }
                render() {
                  var _a, _b;
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  this.container.classList.add("textWidgetAnnotation");
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.value || "";
                    const maxLen = storage.getValue(id, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    let fieldFormattedValues = storedData.formattedValue || ((_a = this.data.textContent) == null ? void 0 : _a.join("\n")) || null;
                    if (fieldFormattedValues && this.data.comb) {
                      fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: fieldFormattedValues,
                      lastCommittedValue: null,
                      commitKey: 1
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = fieldFormattedValues ?? textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", fieldFormattedValues ?? textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    if (this.data.hasOwnCanvas) {
                      element.hidden = true;
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.baseFieldName || this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                      elementData.formattedValue = null;
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue ?? "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("focus", (event) => {
                        const {
                          target
                        } = event;
                        if (elementData.userValue) {
                          target.value = elementData.userValue;
                        }
                        elementData.lastCommittedValue = target.value;
                        elementData.commitKey = 1;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        this.showElementAndHideCanvas(jsEvent.target);
                        const actions = {
                          value(event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            var _a2;
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value = elementData.userValue;
                            if (!value || value.length <= charLimit) {
                              return;
                            }
                            value = value.slice(0, charLimit);
                            target.value = elementData.userValue = value;
                            storage.setValue(id, {
                              value
                            });
                            (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        var _a2;
                        elementData.commitKey = 1;
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter" && !this.data.multiLine) {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          elementData.commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value
                        } = event.target;
                        if (elementData.lastCommittedValue === value) {
                          return;
                        }
                        elementData.lastCommittedValue = value;
                        elementData.userValue = value;
                        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        var _a2;
                        if (!event.relatedTarget) {
                          return;
                        }
                        const {
                          value
                        } = event.target;
                        elementData.userValue = value;
                        if (elementData.lastCommittedValue !== value) {
                          (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey: elementData.commitKey,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if ((_b = this.data.actions) == null ? void 0 : _b.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          var _a2;
                          elementData.lastCommittedValue = null;
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: !!parameters.data.hasOwnCanvas
                  });
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== "Off";
                    storage.setValue(id, {
                      value
                    });
                  }
                  this.container.classList.add("buttonWidgetAnnotation", "checkBox");
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.baseFieldName || data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name, id)) {
                      const curChecked = checked && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.classList.add("buttonWidgetAnnotation", "radioButton");
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== data.buttonValue;
                    storage.setValue(id, {
                      value
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.baseFieldName || data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const radio of this._getElementsByName(name, id)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked && radio.id === id;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.classList.add("buttonWidgetAnnotation", "pushButton");
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.classList.add("choiceWidgetAnnotation");
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.baseFieldName || this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (isExport) => {
                    const name = isExport ? "value" : "textContent";
                    const {
                      options,
                      multiple
                    } = selectElement;
                    if (!multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                  };
                  let selectedValues = getValue(false);
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          removeEmptyEntry == null ? void 0 : removeEmptyEntry();
                          const value = event.detail.value;
                          const values = new Set(Array.isArray(value) ? value : [value]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id, {
                            value: getValue(true)
                          });
                          selectedValues = getValue(false);
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id, {
                            value: null,
                            items: []
                          });
                          selectedValues = getValue(false);
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id, {
                            value: getValue(true),
                            items: getItems(event)
                          });
                          selectedValues = getValue(false);
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id, {
                            value: getValue(true)
                          });
                          selectedValues = getValue(false);
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      var _a;
                      const exportValue = getValue(true);
                      storage.setValue(id, {
                        value: exportValue
                      });
                      event.preventDefault();
                      (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value: selectedValues,
                          changeEx: exportValue,
                          willCommit: false,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: getValue(true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const {
                    data,
                    elements
                  } = parameters;
                  const isRenderable = !!(((_a = data.titleObj) == null ? void 0 : _a.str) || ((_b = data.contentsObj) == null ? void 0 : _b.str) || ((_c = data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable
                  });
                  this.elements = elements;
                }
                render() {
                  this.container.classList.add("popupAnnotation");
                  const popup = new PopupElement({
                    container: this.container,
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText,
                    rect: this.data.rect,
                    parentRect: this.data.parentRect || null,
                    parent: this.parent,
                    elements: this.elements,
                    open: this.data.open
                  });
                  const elementIds = [];
                  for (const element of this.elements) {
                    element.popup = popup;
                    elementIds.push(element.data.id);
                    element.addHighlightArea();
                  }
                  this.container.setAttribute("aria-controls", elementIds.join(","));
                  return this.container;
                }
              }
              class PopupElement {
                constructor({
                  container,
                  color,
                  elements,
                  titleObj,
                  modificationDate,
                  contentsObj,
                  richText,
                  parent,
                  rect,
                  parentRect,
                  open: open2
                }) {
                  __privateAdd(this, _toggle);
                  __privateAdd(this, _show);
                  __privateAdd(this, _hide);
                  __privateAdd(this, _dateTimePromise, null);
                  __privateAdd(this, _boundHide, __privateMethod(this, _hide, hide_fn).bind(this));
                  __privateAdd(this, _boundShow, __privateMethod(this, _show, show_fn).bind(this));
                  __privateAdd(this, _boundToggle, __privateMethod(this, _toggle, toggle_fn).bind(this));
                  __privateAdd(this, _color, null);
                  __privateAdd(this, _container, null);
                  __privateAdd(this, _contentsObj, null);
                  __privateAdd(this, _elements, null);
                  __privateAdd(this, _parent, null);
                  __privateAdd(this, _parentRect, null);
                  __privateAdd(this, _pinned, false);
                  __privateAdd(this, _popup, null);
                  __privateAdd(this, _rect, null);
                  __privateAdd(this, _richText, null);
                  __privateAdd(this, _titleObj, null);
                  __privateAdd(this, _wasVisible, false);
                  __privateSet(this, _container, container);
                  __privateSet(this, _titleObj, titleObj);
                  __privateSet(this, _contentsObj, contentsObj);
                  __privateSet(this, _richText, richText);
                  __privateSet(this, _parent, parent);
                  __privateSet(this, _color, color);
                  __privateSet(this, _rect, rect);
                  __privateSet(this, _parentRect, parentRect);
                  __privateSet(this, _elements, elements);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(modificationDate);
                  if (dateObject) {
                    __privateSet(this, _dateTimePromise, parent.l10n.get("annotation_date_string", {
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    }));
                  }
                  this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
                  for (const element of this.trigger) {
                    element.addEventListener("click", __privateGet(this, _boundToggle));
                    element.addEventListener("mouseenter", __privateGet(this, _boundShow));
                    element.addEventListener("mouseleave", __privateGet(this, _boundHide));
                  }
                  __privateGet(this, _container).hidden = true;
                  if (open2) {
                    __privateMethod(this, _toggle, toggle_fn).call(this);
                  }
                }
                render() {
                  if (__privateGet(this, _popup)) {
                    return;
                  }
                  const {
                    page: {
                      view
                    },
                    viewport: {
                      rawDims: {
                        pageWidth,
                        pageHeight,
                        pageX,
                        pageY
                      }
                    }
                  } = __privateGet(this, _parent);
                  const popup = __privateSet(this, _popup, document.createElement("div"));
                  popup.className = "popup";
                  if (__privateGet(this, _color)) {
                    const baseColor = popup.style.outlineColor = _util2.Util.makeHexColor(...__privateGet(this, _color));
                    if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
                      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
                    } else {
                      const BACKGROUND_ENLIGHT = 0.7;
                      popup.style.backgroundColor = _util2.Util.makeHexColor(...__privateGet(this, _color).map((c) => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));
                    }
                  }
                  const header = document.createElement("span");
                  header.className = "header";
                  const title = document.createElement("h1");
                  header.append(title);
                  ({
                    dir: title.dir,
                    str: title.textContent
                  } = __privateGet(this, _titleObj));
                  popup.append(header);
                  if (__privateGet(this, _dateTimePromise)) {
                    const modificationDate = document.createElement("span");
                    modificationDate.classList.add("popupDate");
                    __privateGet(this, _dateTimePromise).then((localized) => {
                      modificationDate.textContent = localized;
                    });
                    header.append(modificationDate);
                  }
                  const contentsObj = __privateGet(this, _contentsObj);
                  const richText = __privateGet(this, _richText);
                  if ((richText == null ? void 0 : richText.str) && (!(contentsObj == null ? void 0 : contentsObj.str) || contentsObj.str === richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.classList.add("richText", "popupContent");
                  } else {
                    const contents = this._formatContents(contentsObj);
                    popup.append(contents);
                  }
                  let useParentRect = !!__privateGet(this, _parentRect);
                  let rect = useParentRect ? __privateGet(this, _parentRect) : __privateGet(this, _rect);
                  for (const element of __privateGet(this, _elements)) {
                    if (!rect || _util2.Util.intersect(element.data.rect, rect) !== null) {
                      rect = element.data.rect;
                      useParentRect = true;
                      break;
                    }
                  }
                  const normalizedRect = _util2.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
                  const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
                  const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
                  const popupLeft = normalizedRect[0] + parentWidth;
                  const popupTop = normalizedRect[1];
                  const {
                    style
                  } = __privateGet(this, _container);
                  style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;
                  style.top = `${100 * (popupTop - pageY) / pageHeight}%`;
                  __privateGet(this, _container).append(popup);
                }
                _formatContents({
                  str,
                  dir
                }) {
                  const p = document.createElement("p");
                  p.classList.add("popupContent");
                  p.dir = dir;
                  const lines = str.split(/(?:\r\n?|\n)/);
                  for (let i = 0, ii = lines.length; i < ii; ++i) {
                    const line = lines[i];
                    p.append(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.append(document.createElement("br"));
                    }
                  }
                  return p;
                }
                forceHide() {
                  __privateSet(this, _wasVisible, this.isVisible);
                  if (!__privateGet(this, _wasVisible)) {
                    return;
                  }
                  __privateGet(this, _container).hidden = true;
                }
                maybeShow() {
                  if (!__privateGet(this, _wasVisible)) {
                    return;
                  }
                  __privateSet(this, _wasVisible, false);
                  __privateGet(this, _container).hidden = false;
                }
                get isVisible() {
                  return __privateGet(this, _container).hidden === false;
                }
              }
              _dateTimePromise = new WeakMap();
              _boundHide = new WeakMap();
              _boundShow = new WeakMap();
              _boundToggle = new WeakMap();
              _color = new WeakMap();
              _container = new WeakMap();
              _contentsObj = new WeakMap();
              _elements = new WeakMap();
              _parent = new WeakMap();
              _parentRect = new WeakMap();
              _pinned = new WeakMap();
              _popup = new WeakMap();
              _rect = new WeakMap();
              _richText = new WeakMap();
              _titleObj = new WeakMap();
              _wasVisible = new WeakMap();
              _toggle = new WeakSet();
              toggle_fn = function() {
                __privateSet(this, _pinned, !__privateGet(this, _pinned));
                if (__privateGet(this, _pinned)) {
                  __privateMethod(this, _show, show_fn).call(this);
                  __privateGet(this, _container).addEventListener("click", __privateGet(this, _boundToggle));
                } else {
                  __privateMethod(this, _hide, hide_fn).call(this);
                  __privateGet(this, _container).removeEventListener("click", __privateGet(this, _boundToggle));
                }
              };
              _show = new WeakSet();
              show_fn = function() {
                if (!__privateGet(this, _popup)) {
                  this.render();
                }
                if (!this.isVisible) {
                  __privateGet(this, _container).hidden = false;
                  __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) + 1e3;
                } else if (__privateGet(this, _pinned)) {
                  __privateGet(this, _container).classList.add("focused");
                }
              };
              _hide = new WeakSet();
              hide_fn = function() {
                __privateGet(this, _container).classList.remove("focused");
                if (__privateGet(this, _pinned)) {
                  return;
                }
                __privateGet(this, _container).hidden = true;
                __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) - 1e3;
              };
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                  this.annotationEditorType = _util2.AnnotationEditorType.FREETEXT;
                }
                render() {
                  this.container.classList.add("freeTextAnnotation");
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.classList.add("annotationTextContent");
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
              }
              exports2.FreeTextAnnotationElement = FreeTextAnnotationElement;
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _line, null);
                }
                render() {
                  this.container.classList.add("lineAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const line = __privateSet(this, _line, this.svgFactory.createElement("svg:line"));
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  if (!data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _line);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _line = new WeakMap();
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _square, null);
                }
                render() {
                  this.container.classList.add("squareAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const square = __privateSet(this, _square, this.svgFactory.createElement("svg:rect"));
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  if (!data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _square);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _square = new WeakMap();
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _circle, null);
                }
                render() {
                  this.container.classList.add("circleAnnotation");
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = __privateSet(this, _circle, this.svgFactory.createElement("svg:ellipse"));
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  if (!data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _circle);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _circle = new WeakMap();
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _polyline, null);
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.classList.add(this.containerClassName);
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  const polyline = __privateSet(this, _polyline, this.svgFactory.createElement(this.svgElementName));
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  if (!data.popupRef) {
                    this._createPopup(polyline, data);
                  }
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _polyline);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _polyline = new WeakMap();
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.classList.add("caretAnnotation");
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  __privateAdd(this, _polylines, []);
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                  this.annotationEditorType = _util2.AnnotationEditorType.INK;
                }
                render() {
                  this.container.classList.add(this.containerClassName);
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(`${x},${y}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    __privateGet(this, _polylines).push(polyline);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    if (!data.popupRef) {
                      this._createPopup(polyline, data);
                    }
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _polylines);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
              }
              _polylines = new WeakMap();
              exports2.InkAnnotationElement = InkAnnotationElement;
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.classList.add("highlightAnnotation");
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.classList.add("underlineAnnotation");
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.classList.add("squigglyAnnotation");
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.classList.add("strikeoutAnnotation");
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a, _b, _c;
                  const isRenderable = !!(parameters.data.popupRef || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.classList.add("stampAnnotation");
                  if (!this.data.popupRef) {
                    this._createPopup();
                  }
                  return this.container;
                }
              }
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  var _a;
                  super(parameters, {
                    isRenderable: true
                  });
                  __privateAdd(this, _trigger, null);
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename, true);
                  this.content = content;
                  (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  var _a, _b;
                  this.container.classList.add("fileAttachmentAnnotation");
                  let trigger;
                  if (this.data.hasAppearance) {
                    trigger = document.createElement("div");
                  } else {
                    trigger = document.createElement("img");
                    trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(this.data.name) ? "paperclip" : "pushpin"}.svg`;
                  }
                  trigger.classList.add("popupTriggerArea");
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  __privateSet(this, _trigger, trigger);
                  if (!this.data.popupRef && (((_a = this.data.titleObj) == null ? void 0 : _a.str) || ((_b = this.data.contentsObj) == null ? void 0 : _b.str) || this.data.richText)) {
                    this._createPopup();
                  }
                  this.container.append(trigger);
                  return this.container;
                }
                getElementsToTriggerPopup() {
                  return __privateGet(this, _trigger);
                }
                addHighlightArea() {
                  this.container.classList.add("highlightArea");
                }
                _download() {
                  var _a;
                  (_a = this.downloadManager) == null ? void 0 : _a.openOrDownloadData(this.container, this.content, this.filename);
                }
              }
              _trigger = new WeakMap();
              class AnnotationLayer {
                constructor({
                  div,
                  accessibilityManager,
                  annotationCanvasMap,
                  l10n,
                  page,
                  viewport
                }) {
                  __privateAdd(this, _appendElement);
                  __privateAdd(this, _setAnnotationCanvasMap);
                  __privateAdd(this, _accessibilityManager, null);
                  __privateAdd(this, _annotationCanvasMap, null);
                  __privateAdd(this, _editableAnnotations, /* @__PURE__ */ new Map());
                  this.div = div;
                  __privateSet(this, _accessibilityManager, accessibilityManager);
                  __privateSet(this, _annotationCanvasMap, annotationCanvasMap);
                  this.l10n = l10n;
                  this.page = page;
                  this.viewport = viewport;
                  this.zIndex = 0;
                  const {
                    NullL10n
                  } = __w_pdfjs_require__2(32);
                  this.l10n || (this.l10n = NullL10n);
                }
                async render(params) {
                  const {
                    annotations
                  } = params;
                  const layer = this.div;
                  (0, _display_utils2.setLayerDimensions)(layer, this.viewport);
                  const popupToElements = /* @__PURE__ */ new Map();
                  const elementParams = {
                    data: null,
                    layer,
                    linkService: params.linkService,
                    downloadManager: params.downloadManager,
                    imageResourcesPath: params.imageResourcesPath || "",
                    renderForms: params.renderForms !== false,
                    svgFactory: new _display_utils2.DOMSVGFactory(),
                    annotationStorage: params.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                    enableScripting: params.enableScripting === true,
                    hasJSActions: params.hasJSActions,
                    fieldObjects: params.fieldObjects,
                    parent: this,
                    elements: null
                  };
                  for (const data of annotations) {
                    if (data.noHTML) {
                      continue;
                    }
                    const isPopupAnnotation = data.annotationType === _util2.AnnotationType.POPUP;
                    if (!isPopupAnnotation) {
                      const {
                        width,
                        height
                      } = getRectDims(data.rect);
                      if (width <= 0 || height <= 0) {
                        continue;
                      }
                    } else {
                      const elements = popupToElements.get(data.id);
                      if (!elements) {
                        continue;
                      }
                      elementParams.elements = elements;
                    }
                    elementParams.data = data;
                    const element = AnnotationElementFactory.create(elementParams);
                    if (!element.isRenderable) {
                      continue;
                    }
                    if (!isPopupAnnotation && data.popupRef) {
                      const elements = popupToElements.get(data.popupRef);
                      if (!elements) {
                        popupToElements.set(data.popupRef, [element]);
                      } else {
                        elements.push(element);
                      }
                    }
                    if (element.annotationEditorType > 0) {
                      __privateGet(this, _editableAnnotations).set(element.data.id, element);
                    }
                    const rendered = element.render();
                    if (data.hidden) {
                      rendered.style.visibility = "hidden";
                    }
                    if (Array.isArray(rendered)) {
                      for (const renderedElement of rendered) {
                        __privateMethod(this, _appendElement, appendElement_fn).call(this, renderedElement, data.id);
                      }
                    } else {
                      __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id);
                    }
                  }
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                  await this.l10n.translate(layer);
                }
                update({
                  viewport
                }) {
                  const layer = this.div;
                  this.viewport = viewport;
                  (0, _display_utils2.setLayerDimensions)(layer, {
                    rotation: viewport.rotation
                  });
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                  layer.hidden = false;
                }
                getEditableAnnotations() {
                  return Array.from(__privateGet(this, _editableAnnotations).values());
                }
                getEditableAnnotation(id) {
                  return __privateGet(this, _editableAnnotations).get(id);
                }
              }
              _accessibilityManager = new WeakMap();
              _annotationCanvasMap = new WeakMap();
              _editableAnnotations = new WeakMap();
              _appendElement = new WeakSet();
              appendElement_fn = function(element, id) {
                var _a;
                const contentElement = element.firstChild || element;
                contentElement.id = `${_display_utils2.AnnotationPrefix}${id}`;
                this.div.append(element);
                (_a = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a.moveElementInDOM(this.div, element, contentElement, false);
              };
              _setAnnotationCanvasMap = new WeakSet();
              setAnnotationCanvasMap_fn = function() {
                if (!__privateGet(this, _annotationCanvasMap)) {
                  return;
                }
                const layer = this.div;
                for (const [id, canvas] of __privateGet(this, _annotationCanvasMap)) {
                  const element = layer.querySelector(`[data-annotation-id="${id}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                __privateGet(this, _annotationCanvasMap).clear();
              };
              exports2.AnnotationLayer = AnnotationLayer;
            },
            /* 30 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n) {
                return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
              }
              class ColorConverters {
                static CMYK_G([c, y, m, k]) {
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
                static G_CMYK([g]) {
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
                static G_RGB([g]) {
                  return ["RGB", g, g, g];
                }
                static G_HTML([g]) {
                  const G = makeColorComp(g);
                  return `#${G}${G}${G}`;
                }
                static RGB_G([r, g, b]) {
                  return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                }
                static RGB_HTML([r, g, b]) {
                  const R = makeColorComp(r);
                  const G = makeColorComp(g);
                  const B = makeColorComp(b);
                  return `#${R}${G}${B}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static CMYK_RGB([c, y, m, k]) {
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
                static CMYK_HTML(components) {
                  const rgb = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb);
                }
                static RGB_CMYK([r, g, b]) {
                  const c = 1 - r;
                  const m = 1 - g;
                  const y = 1 - b;
                  const k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 31 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(19);
              class XfaLayer {
                static setupStorage(html, id, element, storage, intent) {
                  const storedData = storage.getValue(id, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id, {
                          value
                        });
                      });
                      break;
                  }
                }
                static setAttributes({
                  html,
                  element,
                  storage = null,
                  intent,
                  linkService
                }) {
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value] of Object.entries(attributes)) {
                    if (value === null || value === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value.length) {
                          html.setAttribute(key, value.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value);
                        break;
                      case "style":
                        Object.assign(html.style, value);
                        break;
                      case "textContent":
                        html.textContent = value;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  var _a;
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    const [parent, i, html] = stack.at(-1);
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name
                    } = child;
                    if (name === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    let childHtml;
                    if ((_a = child == null ? void 0 : child.attributes) == null ? void 0 : _a.xmlns) {
                      childHtml = document.createElementNS(child.attributes.xmlns, name);
                    } else {
                      childHtml = document.createElement(name);
                    }
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 32 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NullL10n = void 0;
              exports2.getL10nFallback = getL10nFallback;
              const DEFAULT_L10N_STRINGS = {
                of_pages: "of {{pagesCount}}",
                page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                document_properties_date_string: "{{date}}, {{time}}",
                document_properties_page_size_unit_inches: "in",
                document_properties_page_size_unit_millimeters: "mm",
                document_properties_page_size_orientation_portrait: "portrait",
                document_properties_page_size_orientation_landscape: "landscape",
                document_properties_page_size_name_a3: "A3",
                document_properties_page_size_name_a4: "A4",
                document_properties_page_size_name_letter: "Letter",
                document_properties_page_size_name_legal: "Legal",
                document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
                document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                document_properties_linearized_yes: "Yes",
                document_properties_linearized_no: "No",
                additional_layers: "Additional Layers",
                page_landmark: "Page {{page}}",
                thumb_page_title: "Page {{page}}",
                thumb_page_canvas: "Thumbnail of Page {{page}}",
                find_reached_top: "Reached top of document, continued from bottom",
                find_reached_bottom: "Reached end of document, continued from top",
                "find_match_count[one]": "{{current}} of {{total}} match",
                "find_match_count[other]": "{{current}} of {{total}} matches",
                "find_match_count_limit[one]": "More than {{limit}} match",
                "find_match_count_limit[other]": "More than {{limit}} matches",
                find_not_found: "Phrase not found",
                page_scale_width: "Page Width",
                page_scale_fit: "Page Fit",
                page_scale_auto: "Automatic Zoom",
                page_scale_actual: "Actual Size",
                page_scale_percent: "{{scale}}%",
                loading_error: "An error occurred while loading the PDF.",
                invalid_file_error: "Invalid or corrupted PDF file.",
                missing_file_error: "Missing PDF file.",
                unexpected_response_error: "Unexpected server response.",
                rendering_error: "An error occurred while rendering the page.",
                annotation_date_string: "{{date}}, {{time}}",
                printing_not_supported: "Warning: Printing is not fully supported by this browser.",
                printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
                web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
                free_text2_default_content: "Start typing…",
                editor_free_text2_aria_label: "Text Editor",
                editor_ink2_aria_label: "Draw Editor",
                editor_ink_canvas_aria_label: "User-created image"
              };
              {
                DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
              }
              function getL10nFallback(key, args) {
                switch (key) {
                  case "find_match_count":
                    key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
                    break;
                  case "find_match_count_limit":
                    key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
                    break;
                }
                return DEFAULT_L10N_STRINGS[key] || "";
              }
              function formatL10nValue(text, args) {
                if (!args) {
                  return text;
                }
                return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                  return name in args ? args[name] : "{{" + name + "}}";
                });
              }
              const NullL10n = {
                async getLanguage() {
                  return "en-us";
                },
                async getDirection() {
                  return "ltr";
                },
                async get(key, args = null, fallback = getL10nFallback(key, args)) {
                  return formatL10nValue(fallback, args);
                },
                async translate(element) {
                }
              };
              exports2.NullL10n = NullL10n;
            },
            /* 33 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _aspectRatio, _baseHeight, _baseWidth, _boundCanvasContextMenu, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _currentPath2D, _disableEditing, _hasSomethingToDraw, _isCanvasInitialized, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _endPath, endPath_fn, _stopDrawing, stopDrawing_fn, _drawPoints, drawPoints_fn, _makeBezierCurve, makeBezierCurve_fn, _generateBezierPoints, generateBezierPoints_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _toPDFCoordinates, toPDFCoordinates_fn, _fromPDFCoordinates, fromPDFCoordinates_fn, _serializePaths, serializePaths_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn, _setMinDims, setMinDims_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(4);
              var _annotation_layer = __w_pdfjs_require__2(29);
              var _tools = __w_pdfjs_require__2(5);
              const RESIZER_SIZE = 16;
              const _InkEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  __privateAdd(this, _updateThickness);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _updateOpacity);
                  __privateAdd(this, _getInitialBBox);
                  __privateAdd(this, _setStroke);
                  __privateAdd(this, _startDrawing);
                  __privateAdd(this, _draw);
                  __privateAdd(this, _endPath);
                  __privateAdd(this, _stopDrawing);
                  __privateAdd(this, _drawPoints);
                  __privateAdd(this, _makeBezierCurve);
                  __privateAdd(this, _generateBezierPoints);
                  __privateAdd(this, _redraw);
                  __privateAdd(this, _endDrawing);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _setCanvasDims);
                  __privateAdd(this, _setScaleFactor);
                  __privateAdd(this, _updateTransform);
                  __privateAdd(this, _serializePaths);
                  __privateAdd(this, _getBbox);
                  __privateAdd(this, _getPadding);
                  __privateAdd(this, _fitToContent);
                  __privateAdd(this, _setMinDims);
                  __privateAdd(this, _aspectRatio, 0);
                  __privateAdd(this, _baseHeight, 0);
                  __privateAdd(this, _baseWidth, 0);
                  __privateAdd(this, _boundCanvasContextMenu, this.canvasContextMenu.bind(this));
                  __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                  __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                  __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                  __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                  __privateAdd(this, _currentPath2D, new Path2D());
                  __privateAdd(this, _disableEditing, false);
                  __privateAdd(this, _hasSomethingToDraw, false);
                  __privateAdd(this, _isCanvasInitialized, false);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _realWidth, 0);
                  __privateAdd(this, _realHeight, 0);
                  __privateAdd(this, _requestFrameCallback, null);
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.allRawPaths = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink2_aria_label"].map((str) => [str, l10n.get(str)]));
                }
                static updateDefaultParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _InkEditor._defaultThickness = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _InkEditor._defaultColor = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _InkEditor._defaultOpacity = value / 100;
                      break;
                  }
                }
                updateParams(type, value) {
                  switch (type) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  __privateGet(this, _observer).disconnect();
                  __privateSet(this, _observer, null);
                  super.remove();
                }
                setParent(parent) {
                  if (!this.parent && parent) {
                    this._uiManager.removeShouldRescale(this);
                  } else if (this.parent && parent === null) {
                    this._uiManager.addShouldRescale(this);
                  }
                  super.setParent(parent);
                }
                onScaleChanging() {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  const width = this.width * parentWidth;
                  const height = this.height * parentHeight;
                  this.setDimensions(width, height);
                }
                enableEditMode() {
                  if (__privateGet(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this.div.draggable = false;
                  this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this.div.draggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                }
                onceAdded() {
                  this.div.draggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (__privateGet(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  __privateSet(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                  this.parent.addInkEditorIfNeeded(true);
                  this.parent.moveEditorInDOM(this);
                  this.div.focus({
                    preventScroll: true
                  });
                }
                focusin(event) {
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  event.preventDefault();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasContextMenu(event) {
                  event.preventDefault();
                }
                canvasPointermove(event) {
                  event.preventDefault();
                  __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  event.preventDefault();
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                }
                canvasPointerleave(event) {
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  _InkEditor._l10nPromise.get("editor_ink2_aria_label").then((msg) => {
                    var _a;
                    return (_a = this.div) == null ? void 0 : _a.setAttribute("aria-label", msg);
                  });
                  const [x, y, w, h] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                  this.setAt(x, y, 0, 0);
                  this.setDims(w, h);
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    __privateSet(this, _isCanvasInitialized, true);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                    __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  return this.div;
                }
                setDimensions(width, height) {
                  const roundedWidth = Math.round(width);
                  const roundedHeight = Math.round(height);
                  if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  __privateSet(this, _realWidth, roundedWidth);
                  __privateSet(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  if (__privateGet(this, _aspectRatio) && Math.abs(__privateGet(this, _aspectRatio) - width / height) > 0.01) {
                    height = Math.ceil(width / __privateGet(this, _aspectRatio));
                    this.setDims(width, height);
                  }
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.width = width / parentWidth;
                  this.height = height / parentHeight;
                  if (__privateGet(this, _disableEditing)) {
                    __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width, height);
                  }
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.canvas.style.visibility = "visible";
                  this.fixDims();
                }
                static deserialize(data, parent, uiManager) {
                  var _a, _b, _c;
                  if (data instanceof _annotation_layer.InkAnnotationElement) {
                    return null;
                  }
                  const editor = super.deserialize(data, parent, uiManager);
                  editor.thickness = data.thickness;
                  editor.color = _util2.Util.makeHexColor(...data.color);
                  editor.opacity = data.opacity;
                  const [pageWidth, pageHeight] = editor.pageDimensions;
                  const width = editor.width * pageWidth;
                  const height = editor.height * pageHeight;
                  const scaleFactor = editor.parentScale;
                  const padding = data.thickness / 2;
                  __privateSet(editor, _aspectRatio, width / height);
                  __privateSet(editor, _disableEditing, true);
                  __privateSet(editor, _realWidth, Math.round(width));
                  __privateSet(editor, _realHeight, Math.round(height));
                  const {
                    paths,
                    rect,
                    rotation
                  } = data;
                  for (let {
                    bezier
                  } of paths) {
                    bezier = __privateMethod(_a = _InkEditor, _fromPDFCoordinates, fromPDFCoordinates_fn).call(_a, bezier, rect, rotation);
                    const path = [];
                    editor.paths.push(path);
                    let p0 = scaleFactor * (bezier[0] - padding);
                    let p1 = scaleFactor * (bezier[1] - padding);
                    for (let i = 2, ii = bezier.length; i < ii; i += 6) {
                      const p10 = scaleFactor * (bezier[i] - padding);
                      const p11 = scaleFactor * (bezier[i + 1] - padding);
                      const p20 = scaleFactor * (bezier[i + 2] - padding);
                      const p21 = scaleFactor * (bezier[i + 3] - padding);
                      const p30 = scaleFactor * (bezier[i + 4] - padding);
                      const p31 = scaleFactor * (bezier[i + 5] - padding);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                    editor.bezierPath2D.push(path2D);
                  }
                  const bbox = __privateMethod(_b = editor, _getBbox, getBbox_fn).call(_b);
                  __privateSet(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                  __privateSet(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                  __privateMethod(_c = editor, _setScaleFactor, setScaleFactor_fn).call(_c, width, height);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
                    pageIndex: this.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let InkEditor = _InkEditor;
              _aspectRatio = new WeakMap();
              _baseHeight = new WeakMap();
              _baseWidth = new WeakMap();
              _boundCanvasContextMenu = new WeakMap();
              _boundCanvasPointermove = new WeakMap();
              _boundCanvasPointerleave = new WeakMap();
              _boundCanvasPointerup = new WeakMap();
              _boundCanvasPointerdown = new WeakMap();
              _currentPath2D = new WeakMap();
              _disableEditing = new WeakMap();
              _hasSomethingToDraw = new WeakMap();
              _isCanvasInitialized = new WeakMap();
              _observer = new WeakMap();
              _realWidth = new WeakMap();
              _realHeight = new WeakMap();
              _requestFrameCallback = new WeakMap();
              _updateThickness = new WeakSet();
              updateThickness_fn = function(thickness) {
                const savedThickness = this.thickness;
                this.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = this.color;
                this.addCommands({
                  cmd: () => {
                    this.color = color;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateOpacity = new WeakSet();
              updateOpacity_fn = function(opacity) {
                opacity /= 100;
                const savedOpacity = this.opacity;
                this.addCommands({
                  cmd: () => {
                    this.opacity = opacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _getInitialBBox = new WeakSet();
              getInitialBBox_fn = function() {
                const {
                  parentRotation,
                  parentDimensions: [width, height]
                } = this;
                switch (parentRotation) {
                  case 90:
                    return [0, height, height, width];
                  case 180:
                    return [width, height, width, height];
                  case 270:
                    return [width, 0, height, width];
                  default:
                    return [0, 0, width, height];
                }
              };
              _setStroke = new WeakSet();
              setStroke_fn = function() {
                const {
                  ctx,
                  color,
                  opacity,
                  thickness,
                  parentScale,
                  scaleFactor
                } = this;
                ctx.lineWidth = thickness * parentScale / scaleFactor;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.miterLimit = 10;
                ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;
              };
              _startDrawing = new WeakSet();
              startDrawing_fn = function(x, y) {
                this.canvas.addEventListener("contextmenu", __privateGet(this, _boundCanvasContextMenu));
                this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                this.isEditing = true;
                if (!__privateGet(this, _isCanvasInitialized)) {
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.thickness || (this.thickness = _InkEditor._defaultThickness);
                  this.color || (this.color = _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  this.opacity ?? (this.opacity = _InkEditor._defaultOpacity);
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _hasSomethingToDraw, false);
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                __privateSet(this, _requestFrameCallback, () => {
                  __privateMethod(this, _drawPoints, drawPoints_fn).call(this);
                  if (__privateGet(this, _requestFrameCallback)) {
                    window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                  }
                });
                window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
              };
              _draw = new WeakSet();
              draw_fn = function(x, y) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (this.currentPath.length > 1 && x === lastX && y === lastY) {
                  return;
                }
                const currentPath = this.currentPath;
                let path2D = __privateGet(this, _currentPath2D);
                currentPath.push([x, y]);
                __privateSet(this, _hasSomethingToDraw, true);
                if (currentPath.length <= 2) {
                  path2D.moveTo(...currentPath[0]);
                  path2D.lineTo(x, y);
                  return;
                }
                if (currentPath.length === 3) {
                  __privateSet(this, _currentPath2D, path2D = new Path2D());
                  path2D.moveTo(...currentPath[0]);
                }
                __privateMethod(this, _makeBezierCurve, makeBezierCurve_fn).call(this, path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);
              };
              _endPath = new WeakSet();
              endPath_fn = function() {
                if (this.currentPath.length === 0) {
                  return;
                }
                const lastPoint = this.currentPath.at(-1);
                __privateGet(this, _currentPath2D).lineTo(...lastPoint);
              };
              _stopDrawing = new WeakSet();
              stopDrawing_fn = function(x, y) {
                __privateSet(this, _requestFrameCallback, null);
                x = Math.min(Math.max(x, 0), this.canvas.width);
                y = Math.min(Math.max(y, 0), this.canvas.height);
                __privateMethod(this, _draw, draw_fn).call(this, x, y);
                __privateMethod(this, _endPath, endPath_fn).call(this);
                let bezier;
                if (this.currentPath.length !== 1) {
                  bezier = __privateMethod(this, _generateBezierPoints, generateBezierPoints_fn).call(this);
                } else {
                  const xy = [x, y];
                  bezier = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = __privateGet(this, _currentPath2D);
                const currentPath = this.currentPath;
                this.currentPath = [];
                __privateSet(this, _currentPath2D, new Path2D());
                const cmd = () => {
                  this.allRawPaths.push(currentPath);
                  this.paths.push(bezier);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.allRawPaths.pop();
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                      __privateMethod(this, _createObserver, createObserver_fn).call(this);
                    }
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  }
                };
                this.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              };
              _drawPoints = new WeakSet();
              drawPoints_fn = function() {
                if (!__privateGet(this, _hasSomethingToDraw)) {
                  return;
                }
                __privateSet(this, _hasSomethingToDraw, false);
                const thickness = Math.ceil(this.thickness * this.parentScale);
                const lastPoints = this.currentPath.slice(-3);
                const x = lastPoints.map((xy) => xy[0]);
                const y = lastPoints.map((xy) => xy[1]);
                const xMin = Math.min(...x) - thickness;
                const xMax = Math.max(...x) + thickness;
                const yMin = Math.min(...y) - thickness;
                const yMax = Math.max(...y) + thickness;
                const {
                  ctx
                } = this;
                ctx.save();
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
                ctx.stroke(__privateGet(this, _currentPath2D));
                ctx.restore();
              };
              _makeBezierCurve = new WeakSet();
              makeBezierCurve_fn = function(path2D, x0, y0, x1, y1, x2, y2) {
                const prevX = (x0 + x1) / 2;
                const prevY = (y0 + y1) / 2;
                const x3 = (x1 + x2) / 2;
                const y3 = (y1 + y2) / 2;
                path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
              };
              _generateBezierPoints = new WeakSet();
              generateBezierPoints_fn = function() {
                const path = this.currentPath;
                if (path.length <= 2) {
                  return [[path[0], path[0], path.at(-1), path.at(-1)]];
                }
                const bezierPoints = [];
                let i;
                let [x0, y0] = path[0];
                for (i = 1; i < path.length - 2; i++) {
                  const [x12, y12] = path[i];
                  const [x22, y22] = path[i + 1];
                  const x3 = (x12 + x22) / 2;
                  const y3 = (y12 + y22) / 2;
                  const control12 = [x0 + 2 * (x12 - x0) / 3, y0 + 2 * (y12 - y0) / 3];
                  const control22 = [x3 + 2 * (x12 - x3) / 3, y3 + 2 * (y12 - y3) / 3];
                  bezierPoints.push([[x0, y0], control12, control22, [x3, y3]]);
                  [x0, y0] = [x3, y3];
                }
                const [x1, y1] = path[i];
                const [x2, y2] = path[i + 1];
                const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
                const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
                bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
                return bezierPoints;
              };
              _redraw = new WeakSet();
              redraw_fn = function() {
                if (this.isEmpty()) {
                  __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                  return;
                }
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              };
              _endDrawing = new WeakSet();
              endDrawing_fn = function(event) {
                this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                setTimeout(() => {
                  this.canvas.removeEventListener("contextmenu", __privateGet(this, _boundCanvasContextMenu));
                }, 10);
                __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
                this.addToAnnotationStorage();
                this.setInBackground();
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                _InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => {
                  var _a;
                  return (_a = this.canvas) == null ? void 0 : _a.setAttribute("aria-label", msg);
                });
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              _setCanvasDims = new WeakSet();
              setCanvasDims_fn = function() {
                if (!__privateGet(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              };
              _setScaleFactor = new WeakSet();
              setScaleFactor_fn = function(width, height) {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                const scaleFactorW = (width - padding) / __privateGet(this, _baseWidth);
                const scaleFactorH = (height - padding) / __privateGet(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              };
              _updateTransform = new WeakSet();
              updateTransform_fn = function() {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
              };
              _buildPath2D = new WeakSet();
              buildPath2D_fn = function(bezier) {
                const path2D = new Path2D();
                for (let i = 0, ii = bezier.length; i < ii; i++) {
                  const [first, control1, control2, second] = bezier[i];
                  if (i === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              };
              _toPDFCoordinates = new WeakSet();
              toPDFCoordinates_fn = function(points, rect, rotation) {
                const [blX, blY, trX, trY] = rect;
                switch (rotation) {
                  case 0:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      points[i] += blX;
                      points[i + 1] = trY - points[i + 1];
                    }
                    break;
                  case 90:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      const x = points[i];
                      points[i] = points[i + 1] + blX;
                      points[i + 1] = x + blY;
                    }
                    break;
                  case 180:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      points[i] = trX - points[i];
                      points[i + 1] += blY;
                    }
                    break;
                  case 270:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      const x = points[i];
                      points[i] = trX - points[i + 1];
                      points[i + 1] = trY - x;
                    }
                    break;
                  default:
                    throw new Error("Invalid rotation");
                }
                return points;
              };
              _fromPDFCoordinates = new WeakSet();
              fromPDFCoordinates_fn = function(points, rect, rotation) {
                const [blX, blY, trX, trY] = rect;
                switch (rotation) {
                  case 0:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      points[i] -= blX;
                      points[i + 1] = trY - points[i + 1];
                    }
                    break;
                  case 90:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      const x = points[i];
                      points[i] = points[i + 1] - blY;
                      points[i + 1] = x - blX;
                    }
                    break;
                  case 180:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      points[i] = trX - points[i];
                      points[i + 1] -= blY;
                    }
                    break;
                  case 270:
                    for (let i = 0, ii = points.length; i < ii; i += 2) {
                      const x = points[i];
                      points[i] = trY - points[i + 1];
                      points[i + 1] = trX - x;
                    }
                    break;
                  default:
                    throw new Error("Invalid rotation");
                }
                return points;
              };
              _serializePaths = new WeakSet();
              serializePaths_fn = function(s, tx, ty, rect) {
                var _a, _b;
                const paths = [];
                const padding = this.thickness / 2;
                const shiftX = s * tx + padding;
                const shiftY = s * ty + padding;
                for (const bezier of this.paths) {
                  const buffer = [];
                  const points = [];
                  for (let j = 0, jj = bezier.length; j < jj; j++) {
                    const [first, control1, control2, second] = bezier[j];
                    const p10 = s * first[0] + shiftX;
                    const p11 = s * first[1] + shiftY;
                    const p20 = s * control1[0] + shiftX;
                    const p21 = s * control1[1] + shiftY;
                    const p30 = s * control2[0] + shiftX;
                    const p31 = s * control2[1] + shiftY;
                    const p40 = s * second[0] + shiftX;
                    const p41 = s * second[1] + shiftY;
                    if (j === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    points.push(p20, p21);
                    if (j === jj - 1) {
                      points.push(p40, p41);
                    }
                  }
                  paths.push({
                    bezier: __privateMethod(_a = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_a, buffer, rect, this.rotation),
                    points: __privateMethod(_b = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_b, points, rect, this.rotation)
                  });
                }
                return paths;
              };
              _getBbox = new WeakSet();
              getBbox_fn = function() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              };
              _getPadding = new WeakSet();
              getPadding_fn = function() {
                return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parentScale) : 0;
              };
              _fitToContent = new WeakSet();
              fitToContent_fn = function(firstTime = false) {
                if (this.isEmpty()) {
                  return;
                }
                if (!__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  return;
                }
                const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                __privateSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                __privateSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                const width = Math.ceil(padding + __privateGet(this, _baseWidth) * this.scaleFactor);
                const height = Math.ceil(padding + __privateGet(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                __privateSet(this, _aspectRatio, width / height);
                __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                __privateSet(this, _realWidth, width);
                __privateSet(this, _realHeight, height);
                this.setDims(width, height);
                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              };
              _setMinDims = new WeakSet();
              setMinDims_fn = function() {
                const {
                  style
                } = this.div;
                if (__privateGet(this, _aspectRatio) >= 1) {
                  style.minHeight = `${RESIZER_SIZE}px`;
                  style.minWidth = `${Math.round(__privateGet(this, _aspectRatio) * RESIZER_SIZE)}px`;
                } else {
                  style.minWidth = `${RESIZER_SIZE}px`;
                  style.minHeight = `${Math.round(RESIZER_SIZE / __privateGet(this, _aspectRatio))}px`;
                }
              };
              __privateAdd(InkEditor, _buildPath2D);
              __privateAdd(InkEditor, _toPDFCoordinates);
              __privateAdd(InkEditor, _fromPDFCoordinates);
              __publicField(InkEditor, "_defaultColor", null);
              __publicField(InkEditor, "_defaultOpacity", 1);
              __publicField(InkEditor, "_defaultThickness", 1);
              __publicField(InkEditor, "_l10nPromise");
              __publicField(InkEditor, "_type", "ink");
              exports2.InkEditor = InkEditor;
            },
            /* 34 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(6);
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(10);
              ;
              const SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              const XML_NS = "http://www.w3.org/XML/1998/namespace";
              const XLINK_NS = "http://www.w3.org/1999/xlink";
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                  return URL.createObjectURL(new Blob([data], {
                    type: contentType
                  }));
                }
                const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                let buffer = `data:${contentType};base64,`;
                for (let i = 0, ii = data.length; i < ii; i += 3) {
                  const b1 = data[i] & 255;
                  const b2 = data[i + 1] & 255;
                  const b3 = data[i + 2] & 255;
                  const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  const d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
              const convertImgDataToPng = function() {
                const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                const CHUNK_WRAPPER_SIZE = 12;
                const crcTable = new Int32Array(256);
                for (let i = 0; i < 256; i++) {
                  let c = i;
                  for (let h = 0; h < 8; h++) {
                    if (c & 1) {
                      c = 3988292384 ^ c >> 1 & 2147483647;
                    } else {
                      c = c >> 1 & 2147483647;
                    }
                  }
                  crcTable[i] = c;
                }
                function crc32(data, start, end) {
                  let crc = -1;
                  for (let i = start; i < end; i++) {
                    const a = (crc ^ data[i]) & 255;
                    const b = crcTable[a];
                    crc = crc >>> 8 ^ b;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  let p = offset;
                  const len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  const crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  let a = 1;
                  let b = 0;
                  for (let i = start; i < end; ++i) {
                    a = (a + (data[i] & 255)) % 65521;
                    b = (b + a) % 65521;
                  }
                  return b << 16 | a;
                }
                function deflateSync(literals) {
                  if (!_is_node2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    let input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = Buffer.from(literals);
                    }
                    const output = require_zlib().deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  let len = literals.length;
                  const maxBlockLength = 65535;
                  const deflateBlocks = Math.ceil(len / maxBlockLength);
                  const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  let pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  let pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  const adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode2(imgData, kind, forceDataSchema, isMask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  let bitDepth, colorType, lineSize;
                  const bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  const literals = new Uint8Array((1 + lineSize) * height);
                  let offsetLiterals = 0, offsetBytes = 0;
                  for (let y = 0; y < height; ++y) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (let y = 0; y < height; y++) {
                      offsetLiterals++;
                      for (let i = 0; i < lineSize; i++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  const idat = deflateSync(literals);
                  const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  const data = new Uint8Array(pngLength);
                  let offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return createObjectURL(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode2(imgData, kind, forceDataSchema, isMask);
                };
              }();
              class SVGExtraState {
                constructor() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                clone() {
                  return Object.create(this);
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              }
              function opListToTree(opList) {
                let opTree = [];
                const tmp = [];
                for (const opListElement of opList) {
                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree.at(-1).items;
                    continue;
                  }
                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
                return opTree;
              }
              function pf(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const s = value.toFixed(10);
                let i = s.length - 1;
                if (s[i] !== "0") {
                  return s;
                }
                do {
                  i--;
                } while (s[i] === "0");
                return s.substring(0, s[i] === "." ? i : i + 1);
              }
              function pm(m) {
                if (m[4] === 0 && m[5] === 0) {
                  if (m[1] === 0 && m[2] === 0) {
                    if (m[0] === 1 && m[3] === 1) {
                      return "";
                    }
                    return `scale(${pf(m[0])} ${pf(m[3])})`;
                  }
                  if (m[0] === m[3] && m[1] === -m[2]) {
                    const a = Math.acos(m[0]) * 180 / Math.PI;
                    return `rotate(${pf(a)})`;
                  }
                } else {
                  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                    return `translate(${pf(m[4])} ${pf(m[5])})`;
                  }
                }
                return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
              }
              let clipCount = 0;
              let maskCount = 0;
              let shadingCount = 0;
              class SVGGraphics {
                constructor(commonObjs, objs, forceDataSchema = false) {
                  (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (const op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                save() {
                  this.transformStack.push(this.transformMatrix);
                  const old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
                group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
                loadDependencies(operatorList) {
                  const fnArray = operatorList.fnArray;
                  const argsArray = operatorList.argsArray;
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    if (fnArray[i] !== _util2.OPS.dependency) {
                      continue;
                    }
                    for (const obj of argsArray[i]) {
                      const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                      const promise = new Promise((resolve) => {
                        objsPool.get(obj, resolve);
                      });
                      this.current.dependencies.push(promise);
                    }
                  }
                  return Promise.all(this.current.dependencies);
                }
                transform(a, b, c, d, e, f) {
                  const transformMatrix = [a, b, c, d, e, f];
                  this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
                getSVG(operatorList, viewport) {
                  this.viewport = viewport;
                  const svgElement = this._initialize(viewport);
                  return this.loadDependencies(operatorList).then(() => {
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.executeOpTree(this.convertOpList(operatorList));
                    return svgElement;
                  });
                }
                convertOpList(operatorList) {
                  const operatorIdMapping = this._operatorIdMapping;
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  const opList = [];
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    const fnId = fnArray[i];
                    opList.push({
                      fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i]
                    });
                  }
                  return opListToTree(opList);
                }
                executeOpTree(opTree) {
                  for (const opTreeElement of opTree) {
                    const fn = opTreeElement.fn;
                    const fnId = opTreeElement.fnId;
                    const args = opTreeElement.args;
                    switch (fnId | 0) {
                      case _util2.OPS.beginText:
                        this.beginText();
                        break;
                      case _util2.OPS.dependency:
                        break;
                      case _util2.OPS.setLeading:
                        this.setLeading(args);
                        break;
                      case _util2.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setFont:
                        this.setFont(args);
                        break;
                      case _util2.OPS.showText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.endText:
                        this.endText();
                        break;
                      case _util2.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;
                      case _util2.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;
                      case _util2.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;
                      case _util2.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;
                      case _util2.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;
                      case _util2.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;
                      case _util2.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;
                      case _util2.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;
                      case _util2.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;
                      case _util2.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;
                      case _util2.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;
                      case _util2.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;
                      case _util2.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;
                      case _util2.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;
                      case _util2.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;
                      case _util2.OPS.setGState:
                        this.setGState(args[0]);
                        break;
                      case _util2.OPS.fill:
                        this.fill();
                        break;
                      case _util2.OPS.eoFill:
                        this.eoFill();
                        break;
                      case _util2.OPS.stroke:
                        this.stroke();
                        break;
                      case _util2.OPS.fillStroke:
                        this.fillStroke();
                        break;
                      case _util2.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;
                      case _util2.OPS.clip:
                        this.clip("nonzero");
                        break;
                      case _util2.OPS.eoClip:
                        this.clip("evenodd");
                        break;
                      case _util2.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;
                      case _util2.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;
                      case _util2.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;
                      case _util2.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;
                      case _util2.OPS.closePath:
                        this.closePath();
                        break;
                      case _util2.OPS.closeStroke:
                        this.closeStroke();
                        break;
                      case _util2.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;
                      case _util2.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;
                      case _util2.OPS.nextLine:
                        this.nextLine();
                        break;
                      case _util2.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;
                      case _util2.OPS.endPath:
                        this.endPath();
                        break;
                      case 92:
                        this.group(opTreeElement.items);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented operator ${fn}`);
                        break;
                    }
                  }
                }
                setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
                setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                setTextMatrix(a, b, c, d, e, f) {
                  const current = this.current;
                  current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                  current.textMatrixScale = Math.hypot(a, b);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.append(current.tspan);
                }
                beginText() {
                  const current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util2.IDENTITY_MATRIX;
                  current.lineMatrix = _util2.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                  current.ycoords = [];
                }
                moveText(x, y) {
                  const current = this.current;
                  current.x = current.lineX += x;
                  current.y = current.lineY += y;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  let x = 0;
                  for (const glyph of glyphs) {
                    if (glyph === null) {
                      x += fontDirection * wordSpacing;
                      continue;
                    } else if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      let vx;
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (glyph.isInFont || font.missingFile) {
                      current.xcoords.push(current.x + scaledX);
                      if (vertical) {
                        current.ycoords.push(-current.y + scaledY);
                      }
                      current.tspan.textContent += character;
                    } else {
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                  }
                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  if (vertical) {
                    current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                  } else {
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }
                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    const lineWidthScale = 1 / (current.textMatrixScale || 1);
                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }
                  let textMatrix = current.textMatrix;
                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }
                  current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.append(current.tspan);
                  current.txtgrp.append(current.txtElement);
                  this._ensureTransformGroup().append(current.txtElement);
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                addFontStyle(fontObj) {
                  if (!fontObj.data) {
                    throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                  }
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.append(this.cssStyle);
                  }
                  const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                }
                setFont(details) {
                  const current = this.current;
                  const fontObj = this.commonObjs.get(details[0]);
                  let size = details[1];
                  current.font = fontObj;
                  if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                  current.ycoords = [];
                }
                endText() {
                  var _a;
                  const current = this.current;
                  if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && ((_a = current.txtElement) == null ? void 0 : _a.hasChildNodes())) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
                setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
                setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
                setStrokeRGBColor(r, g, b) {
                  this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                }
                setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
                setFillRGBColor(r, g, b) {
                  this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                  this.current.ycoords = [];
                }
                setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
                setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
                shadingFill(args) {
                  const {
                    width,
                    height
                  } = this.viewport;
                  const inv = _util2.Util.inverseTransform(this.transformMatrix);
                  const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                  if (this.current.fillAlpha < 1) {
                    rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                  }
                  this._ensureTransformGroup().append(rect);
                }
                _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }
                  return this._makeShadingPattern(args);
                }
                _makeTilingPattern(args) {
                  const color = args[1];
                  const operatorList = args[2];
                  const matrix = args[3] || _util2.IDENTITY_MATRIX;
                  const [x0, y0, x1, y1] = args[4];
                  const xstep = args[5];
                  const ystep = args[6];
                  const paintType = args[7];
                  const tilingId = `shading${shadingCount++}`;
                  const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                  const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                  const txstep = xstep * xscale;
                  const tystep = ystep * yscale;
                  const tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", `${tx0}`);
                  tiling.setAttributeNS(null, "y", `${ty0}`);
                  const svg = this.svg;
                  const transformMatrix = this.transformMatrix;
                  const fillColor = this.current.fillColor;
                  const strokeColor = this.current.strokeColor;
                  const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;
                  if (paintType === 2) {
                    const cssColor = _util2.Util.makeHexColor(...color);
                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }
                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.append(bbox.childNodes[0]);
                  this.defs.append(tiling);
                  return `url(#${tilingId})`;
                }
                _makeShadingPattern(args) {
                  if (typeof args === "string") {
                    args = this.objs.get(args);
                  }
                  switch (args[0]) {
                    case "RadialAxial":
                      const shadingId = `shading${shadingCount++}`;
                      const colorStops = args[3];
                      let gradient;
                      switch (args[1]) {
                        case "axial":
                          const point0 = args[4];
                          const point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;
                        case "radial":
                          const focalPoint = args[4];
                          const circlePoint = args[5];
                          const focalRadius = args[6];
                          const circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;
                        default:
                          throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                      }
                      for (const colorStop of colorStops) {
                        const stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.append(stop);
                      }
                      this.defs.append(gradient);
                      return `url(#${shadingId})`;
                    case "Mesh":
                      (0, _util2.warn)("Unimplemented pattern Mesh");
                      return null;
                    case "Dummy":
                      return "hotpink";
                    default:
                      throw new Error(`Unknown IR type: ${args[0]}`);
                  }
                }
                setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
                constructPath(ops, args) {
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let d = [];
                  let j = 0;
                  for (const op of ops) {
                    switch (op | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("M", pf(x), pf(y));
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("L", pf(x), pf(y));
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        d.push("Z");
                        break;
                    }
                  }
                  d = d.join(" ");
                  if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                    d = current.path.getAttributeNS(null, "d") + d;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");
                    this._ensureTransformGroup().append(current.path);
                  }
                  current.path.setAttributeNS(null, "d", d);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x, y);
                }
                endPath() {
                  const current = this.current;
                  current.path = null;
                  if (!this.pendingClip) {
                    return;
                  }
                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }
                  const clipId = `clippath${clipCount++}`;
                  const clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  const clipElement = current.element.cloneNode(true);
                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }
                  this.pendingClip = null;
                  clipPath.append(clipElement);
                  this.defs.append(clipPath);
                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    for (const prev of this.extraStack) {
                      prev.clipGroup = null;
                    }
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }
                  current.activeClipUrl = `url(#${clipId})`;
                  this.tgrp = null;
                }
                clip(type) {
                  this.pendingClip = type;
                }
                closePath() {
                  const current = this.current;
                  if (current.path) {
                    const d = `${current.path.getAttributeNS(null, "d")}Z`;
                    current.path.setAttributeNS(null, "d", d);
                  }
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
                setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value);
                        break;
                      case "CA":
                        this.setStrokeAlpha(value);
                        break;
                      case "ca":
                        this.setFillAlpha(value);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                        break;
                    }
                  }
                }
                fill() {
                  const current = this.current;
                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
                stroke() {
                  const current = this.current;
                  if (current.element) {
                    this._setStrokeAttributes(current.element);
                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
                _setStrokeAttributes(element, lineWidthScale = 1) {
                  const current = this.current;
                  let dashArray = current.dashArray;
                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function(value) {
                      return lineWidthScale * value;
                    });
                  }
                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
                eoFill() {
                  var _a;
                  (_a = this.current.element) == null ? void 0 : _a.setAttributeNS(null, "fill-rule", "evenodd");
                  this.fill();
                }
                fillStroke() {
                  this.stroke();
                  this.fill();
                }
                eoFillStroke() {
                  var _a;
                  (_a = this.current.element) == null ? void 0 : _a.setAttributeNS(null, "fill-rule", "evenodd");
                  this.fillStroke();
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
                paintSolidColorImageMask() {
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);
                  this._ensureTransformGroup().append(rect);
                }
                paintImageXObject(objId) {
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintInlineImageXObject(imgData, mask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                  if (mask) {
                    mask.append(imgEl);
                  } else {
                    this._ensureTransformGroup().append(imgEl);
                  }
                }
                paintImageMaskXObject(img) {
                  const imgData = this.getObject(img.data, img);
                  if (imgData.bitmap) {
                    (0, _util2.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                    return;
                  }
                  const current = this.current;
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = current.fillColor;
                  current.maskId = `mask${maskCount++}`;
                  const mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                  this.defs.append(mask);
                  this._ensureTransformGroup().append(rect);
                  this.paintInlineImageXObject(imgData, mask);
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                }
                _initialize(viewport) {
                  const svg = this.svgFactory.create(viewport.width, viewport.height);
                  const definitions = this.svgFactory.createElement("svg:defs");
                  svg.append(definitions);
                  this.defs = definitions;
                  const rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.append(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
                _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    const clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.append(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }
                  return this.current.clipGroup;
                }
                _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().append(this.tgrp);
                    } else {
                      this.svg.append(this.tgrp);
                    }
                  }
                  return this.tgrp;
                }
              }
              exports2.SVGGraphics = SVGGraphics;
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AbortException", {
              enumerable: true,
              get: function() {
                return _util2.AbortException;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "FeatureTest", {
              enumerable: true,
              get: function() {
                return _util2.FeatureTest;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "ImageKind", {
              enumerable: true,
              get: function() {
                return _util2.ImageKind;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "PromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.PromiseCapability;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            exports2.SVGGraphics = void 0;
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isDataScheme", {
              enumerable: true,
              get: function() {
                return _display_utils2.isDataScheme;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "normalizeUnicode", {
              enumerable: true,
              get: function() {
                return _util2.normalizeUnicode;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "setLayerDimensions", {
              enumerable: true,
              get: function() {
                return _display_utils2.setLayerDimensions;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "updateTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.updateTextLayer;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(2);
            var _display_utils2 = __w_pdfjs_require__(6);
            var _text_layer = __w_pdfjs_require__(26);
            var _annotation_editor_layer = __w_pdfjs_require__(27);
            var _tools = __w_pdfjs_require__(5);
            var _annotation_layer = __w_pdfjs_require__(29);
            var _worker_options2 = __w_pdfjs_require__(14);
            var _xfa_layer = __w_pdfjs_require__(31);
            const pdfjsVersion = "3.8.162";
            const pdfjsBuild = "2c74323e3";
            const SVGGraphics = __w_pdfjs_require__(34).SVGGraphics;
            exports2.SVGGraphics = SVGGraphics;
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// node_modules/easyinvoice/src/lib/easyinvoice.ts
var import_axios = __toESM(require_axios2());
var import_is_base64 = __toESM(require_is_base64());
var import_file_saver = __toESM(require_FileSaver_min());

// node_modules/js-base64/base64.mjs
var version2 = "3.7.5";
var VERSION = version2;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version: version2,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/easyinvoice/src/lib/easyinvoice.ts
var import_pdfjs_dist = __toESM(require_pdf());
var printJs;
if (typeof window !== "undefined") {
  import("./print-DFZ2RRYC.js").then((module2) => {
    printJs = module2.default;
  }).catch((err) => {
    console.error("Failed to load print-js:", err);
  });
}
(async () => {
  import_pdfjs_dist.GlobalWorkerOptions.workerSrc = await import(
    // @ts-ignore
    "./pdf.worker.entry-7KWSOYUL.js"
  );
})();
var EasyInvoice = class {
  constructor(pdf, totalPages, renderedPdf, elementId) {
    this._pdf = pdf;
    this._totalPages = totalPages;
    this._renderedPdf = renderedPdf;
    this._elementId = elementId;
  }
  createInvoice(options, cb = () => {
  }) {
    return new Promise((resolve, reject) => {
      const url = "https://api.easyinvoice.cloud/v2/free/invoices";
      const data = {
        data: options
      };
      const config = {
        headers: {
          "easyinvoice-source": "npm"
        }
      };
      import_axios.default.create().post(url, data, config).then((response) => {
        const result = response.data.data;
        this._pdf = result.pdf;
        resolve(result);
        cb(result);
      }).catch((error) => {
        console.log(error.response.data);
        reject(error.response.data);
        cb(error.response.data);
      });
    });
  }
  /* istanbul ignore next */
  download(filename = "invoice.pdf", pdf = this._pdf) {
    if (filename === void 0 || (0, import_is_base64.default)(filename)) {
      throw new Error("Invalid filename.");
    }
    if (typeof window === "undefined") {
      throw new Error("Easy Invoice download() is only supported in the browser.");
    } else {
      downloadFile(filename, "application/pdf", pdf);
    }
  }
  /* istanbul ignore next */
  print(pdf = this._pdf) {
    printJs({
      printable: pdf,
      type: "pdf",
      base64: true
    });
  }
  /* istanbul ignore next */
  render(elementId, pdf = this._pdf, cb = () => {
  }) {
    return new Promise((resolve) => {
      if (typeof window === "undefined") {
        throw new Error("Easy Invoice render() is only supported in the browser.");
      } else {
        this._elementId = elementId;
        this.renderPdf(pdf, function(renderFinished) {
          resolve(renderFinished);
          cb(renderFinished);
        });
      }
    });
  }
  /* istanbul ignore next */
  renderPdf(pdfBase64, renderFinished) {
    const loadingTask = (0, import_pdfjs_dist.getDocument)({ data: gBase64.atob(pdfBase64) });
    loadingTask.promise.then((pdf) => {
      this._totalPages = pdf.numPages;
      this._renderedPdf = pdf;
      this.renderPage(1, renderFinished);
    }, function(reason) {
      console.error(reason);
    });
  }
  /* istanbul ignore next */
  renderPage(pageNumber, renderFinished) {
    this._renderedPdf.getPage(pageNumber).then((page) => {
      const canvas = document.createElement("canvas");
      const viewport = isMobileBrowser() ? page.getViewport({ scale: window.screen.width / page.getViewport({ scale: 1 }).width }) : page.getViewport({ scale: Math.max(window.devicePixelRatio || 1, 1) });
      document.getElementById(this._elementId).innerHTML = "";
      const canvasWrapper = document.getElementById(this._elementId);
      canvasWrapper.appendChild(canvas);
      const context = canvas.getContext("2d");
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      const renderContext = {
        canvasContext: context,
        viewport
      };
      const renderTask = page.render(renderContext);
      renderTask.promise.then(function() {
        renderFinished(true);
      });
    });
  }
};
function downloadFile(fileName, contentType, base64) {
  const blob = base64toBlob(base64, contentType);
  import_file_saver.default.saveAs(blob, fileName);
}
function base64toBlob(base64Data, contentType) {
  contentType = contentType || "";
  const sliceSize = 1024;
  const byteCharacters = gBase64.atob(base64Data);
  const bytesLength = byteCharacters.length;
  const slicesCount = Math.ceil(bytesLength / sliceSize);
  const byteArrays = new Array(slicesCount);
  for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
    const begin = sliceIndex * sliceSize;
    const end = Math.min(begin + sliceSize, bytesLength);
    const bytes = new Array(end - begin);
    for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
      bytes[i] = byteCharacters[offset].charCodeAt(0);
    }
    byteArrays[sliceIndex] = new Uint8Array(bytes);
  }
  return new Blob(byteArrays, {
    type: contentType
  });
}
function isMobileBrowser() {
  var ua = navigator.userAgent;
  if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ua.substr(0, 4))) {
    return true;
  } else {
    return false;
  }
}
var easyinvoice_default = new EasyInvoice();
if (typeof window === "undefined") {
  module.exports = new EasyInvoice();
}
globalThis.easyinvoice = new EasyInvoice();

// node_modules/easyinvoice/index-module.js
var index_module_default = easyinvoice_default;
export {
  index_module_default as default
};
//# sourceMappingURL=easyinvoice.js.map
